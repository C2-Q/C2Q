code_snippet,labels
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nresult = maximum_cut(G)\nprint(result)",0
"import networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 4), (3, 4), (4, 5)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (0, 2), (0, 3), (1, 3), (2, 3), (1, 4)])\nresult = maximum_cut(G)\nprint(result)",0
"import networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nresult = maximum_cut(G)\nprint(result)",0
"import networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (0, 2), (2, 3), (3, 4)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (0, 2), (2, 4)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 4), (1, 4), (2, 5)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport itertools\nimport networkx as nx\n\ndef maxcut_bruteforce(G):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for i in range(1, len(nodes)):\n        for cut in itertools.combinations(nodes, i):\n            partition_A = set(cut)\n            partition_B = set(nodes) - partition_A\n            cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n            if cut_value > max_cut_value:\n                max_cut_value = cut_value\n                best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4), (4, 5)])\nmax_cut_value, best_partition = maxcut_bruteforce(G)\nprint(f""Maximum cut value: {max_cut_value}"")\nprint(f""Best partition: {best_partition}"")",0
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_maxcut(G, iterations=1000):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n        if cut_value > max_cut_value:\n            max_cut_value = cut_value\n            best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nmax_cut_value, best_partition = randomized_maxcut(G)\nprint(f""Maximum cut value: {max_cut_value}"")\nprint(f""Best partition: {best_partition}"")",0
"import itertools\nimport networkx as nx\n\ndef maxcut_bruteforce(G):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for i in range(1, len(nodes)):\n        for cut in itertools.combinations(nodes, i):\n            partition_A = set(cut)\n            partition_B = set(nodes) - partition_A\n            cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n            if cut_value > max_cut_value:\n                max_cut_value = cut_value\n                best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4), (4, 5)])\nmax_cut_value, best_partition = maxcut_bruteforce(G)\nprint(f""Maximum cut value: {max_cut_value}"")\nprint(f""Best partition: {best_partition}"")",0
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_maxcut(G, iterations=1000):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n        if cut_value > max_cut_value:\n            max_cut_value = cut_value\n            best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nmax_cut_value, best_partition = randomized_maxcut(G)\nprint(f""Maximum cut value: {max_cut_value}"")\nprint(f""Best partition: {best_partition}"")",0
"import networkx as nx\nimport random\n\ndef randomized_maximal_independent_set(G):\n    independent_set = set()\n    nodes = list(G.nodes())\n    random.shuffle(nodes)\n    while nodes:\n        node = nodes.pop(0)\n        independent_set.add(node)\n        for neighbor in G.neighbors(node):\n            if neighbor in nodes:\n                nodes.remove(neighbor)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nindependent_set = randomized_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef iterative_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = set(G.nodes())\n    while remaining_nodes:\n        node = remaining_nodes.pop()\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes -= neighbors\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = iterative_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"import networkx as nx\n\ndef heuristic_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x), reverse=True)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nindependent_set = heuristic_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef backtrack_maximal_independent_set(G, remaining_nodes=None, independent_set=None):\n    if independent_set is None:\n        independent_set = set()\n    if remaining_nodes is None:\n        remaining_nodes = set(G.nodes())\n    if not remaining_nodes:\n        return independent_set\n    node = remaining_nodes.pop()\n    new_set = independent_set.copy()\n    new_set.add(node)\n    neighbors = set(G.neighbors(node))\n    return backtrack_maximal_independent_set(G, remaining_nodes - neighbors, new_set)\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = backtrack_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef dfs_maximal_independent_set(G):\n    def dfs(node, visited, independent_set):\n        visited.add(node)\n        independent_set.add(node)\n        for neighbor in G.neighbors(node):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                for neighbor_of_neighbor in G.neighbors(neighbor):\n                    if neighbor_of_neighbor not in visited:\n                        dfs(neighbor_of_neighbor, visited, independent_set)\n    visited = set()\n    independent_set = set()\n    for node in G.nodes():\n        if node not in visited:\n            dfs(node, visited, independent_set)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = dfs_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"import networkx as nx\n\ndef degree_based_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x))\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)])\nindependent_set = degree_based_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"import networkx as nx\n\ndef lexicographical_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes())\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = lexicographical_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\nfrom collections import deque\n\ndef bfs_maximal_independent_set(G):\n    independent_set = set()\n    visited = set()\n    queue = deque(G.nodes())\n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            independent_set.add(node)\n            visited.add(node)\n            for neighbor in G.neighbors(node):\n                visited.add(neighbor)\n                for n in G.neighbors(neighbor):\n                    if n not in visited and n not in queue:\n                        queue.append(n)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = bfs_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef degree_first_mis(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x), reverse=True)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = degree_first_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_greedy_mis(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x))\n    random.shuffle(remaining_nodes)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = randomized_greedy_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_degree_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x))\n    random.shuffle(remaining_nodes)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = randomized_degree_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"import networkx as nx\n\ndef greedy_mis_variation(graph):\n    independent_set = set()\n    remaining_nodes = sorted(graph.nodes(), key=lambda x: graph.degree(x), reverse=True)\n    while remaining_nodes:\n        n = remaining_nodes.pop(0)\n        independent_set.add(n)\n        neighbors = set(graph.neighbors(n))\n        remaining_nodes = [node for node in remaining_nodes if node not in neighbors]\n    return independent_set\n\ngraph = nx.Graph()\ngraph.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 5), (5, 0)])\nmis_set = greedy_mis_variation(graph)\nprint(f""Maximal Independent Set: {mis_set}"")",1
"# Python code\nimport itertools\nimport networkx as nx\n\ndef brute_force_maxcut(G):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for i in range(1, len(nodes)):\n        for cut in itertools.combinations(nodes, i):\n            partition_A = set(cut)\n            partition_B = set(nodes) - partition_A\n            cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n            if cut_value > max_cut_value:\n                max_cut_value = cut_value\n                best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value, partition = brute_force_maxcut(G)\nprint(f""Maximum Cut Value: {cut_value}"")\nprint(f""Best Partition: {partition}"")",0
"import networkx as nx\n\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nresult = maximum_cut(G)\nprint(result)",1
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_maxcut(G, iterations=1000):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n        if cut_value > max_cut_value:\n            max_cut_value = cut_value\n            best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nmax_cut_value, best_partition = randomized_maxcut(G)\nprint(f\""Maximum cut value: {max_cut_value}\"")\nprint(f\""Best partition: {best_partition}\"")",1
"""import networkx as nx\n\ndef maximum_cut(G):\n    # Calculate maximum cut value using a greedy algorithm\n    partition_A = set()\n    partition_B = set(G.nodes())\n    for node in G.nodes():\n        # Assign the node to partition based on neighbors\n        if sum(1 for neighbor in G.neighbors(node) if neighbor in partition_A) > sum(1 for neighbor in G.neighbors(node) if neighbor in partition_B):\n            partition_B.add(node)\n        else:\n            partition_A.add(node)\n    # Calculate the maximum cut\n    cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value = maximum_cut(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""import networkx as nx\n\ndef maximum_cut_randomized(G):\n    # Use a randomized approach to solve Maximum Cut\n    import random\n    partition_A = set(random.sample(G.nodes(), len(G.nodes()) // 2))\n    partition_B = set(G.nodes()) - partition_A\n    cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 0)])\ncut_value = maximum_cut_randomized(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef independent_set(G):\n    # Find the independent set of the graph\n    independent_set = set()\n    for node in G.nodes():\n        # Add the node to independent set if none of its neighbors are in the set\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = independent_set(G)\nprint(f\""Independent Set: {result}\"")""",0
"""import networkx as nx\n\ndef independent_set_greedy(G):\n    # Greedy approach to find maximal independent set\n    independent_set = set()\n    for node in sorted(G.nodes(), key=lambda n: G.degree(n)):\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 4), (4, 3)])\nresult = independent_set_greedy(G)\nprint(f\""Maximal Independent Set: {result}\"")""",1
"# Python code\nimport networkx as nx\n\ndef independent_set(G):\n    independent_set = set()\n    for node in G.nodes():\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = independent_set(G)\nprint(f\""Independent Set: {result}\"")",0
"""# Python code\nimport networkx as nx\n\ndef max_cut_greedy_algorithm(graph):\n    # Solve maximum cut using a greedy algorithm\n    set_A = set()\n    set_B = set(graph.nodes())\n    for vertex in graph.nodes():\n        # Assign vertex to partition based on neighbors\n        if sum(1 for neighbor in graph.neighbors(vertex) if neighbor in set_A) > sum(1 for neighbor in graph.neighbors(vertex) if neighbor in set_B):\n            set_B.add(vertex)\n        else:\n            set_A.add(vertex)\n    # Calculate the cut value\n    cut_val = sum(1 for u, v in graph.edges() if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_val\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 0)])\ncut_value = max_cut_greedy_algorithm(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""import networkx as nx\nimport random\n\ndef randomized_maximum_cut_solution(G):\n    # Randomized method to find maximum cut\n    part_A = set(random.sample(G.nodes(), len(G.nodes()) // 2))\n    part_B = set(G.nodes()) - part_A\n    cut_value = sum(1 for u, v in G.edges() if (u in part_A and v in part_B) or (u in part_B and v in part_A))\n    return cut_value\n\n# Create graph\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value = randomized_maximum_cut_solution(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef find_independent_set(G):\n    # Heuristic approach to find maximal independent set\n    ind_set = set()\n    for v in sorted(G.nodes(), key=lambda x: G.degree(x)):\n        # Add node to independent set if none of its neighbors are in the set\n        if all(neighbor not in ind_set for neighbor in G.neighbors(v)):\n            ind_set.add(v)\n    return ind_set\n\n# Example graph\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 4), (4, 3)])\nindependent_set = find_independent_set(G)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""# Python code\nimport networkx as nx\n\ndef independent_set_randomized(graph):\n    # Randomized approach to find maximal independent set\n    import random\n    i_set = set()\n    remaining_nodes = list(graph.nodes())\n    random.shuffle(remaining_nodes)\n    for node in remaining_nodes:\n        if all(neighbor not in i_set for neighbor in graph.neighbors(node)):\n            i_set.add(node)\n    return i_set\n\n# Create graph\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = independent_set_randomized(G)\nprint(f\""Independent Set: {result}\"")""",1
"""import networkx as nx\nfrom itertools import permutations\n\ndef tsp_brute_force(graph):\n    # Brute-force solution for TSP\n    nodes = list(graph.nodes())\n    min_cost = float('inf')\n    best_route = None\n    for route in permutations(nodes):\n        cost = sum(graph[route[i]][route[i+1]]['weight'] for i in range(len(route) - 1)) + graph[route[-1]][route[0]]['weight']\n        if cost < min_cost:\n            min_cost = cost\n            best_route = route\n    return min_cost, best_route\n\n# Create a graph with weighted edges\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\nmin_cost, route = tsp_brute_force(G)",2
"""# Python code\nimport networkx as nx\nfrom itertools import permutations\n\ndef traveling_salesman_dp(graph):\n    # Solve TSP using Dynamic Programming\n    nodes = list(graph.nodes())\n    n = len(nodes)\n    dp = [[None] * (1 << n) for _ in range(n)]\n    def tsp(pos, visited):\n        if visited == (1 << n) - 1:\n            return graph[pos][0]['weight'] if 0 in graph[pos] else float('inf')\n        if dp[pos][visited] is not None:\n            return dp[pos][visited]\n        ans = float('inf')\n        for city in range(n):\n            if visited & (1 << city) == 0 and city in graph[pos]:\n                ans = min(ans, graph[pos][city]['weight'] + tsp(city, visited | (1 << city)))\n        dp[pos][visited] = ans\n        return ans\n    return tsp(0, 1)\n\n# Example graph with weighted edges\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 12), (1, 2, 10), (2, 3, 8), (3, 0, 15)])\nmin_cost = traveling_salesman_dp(G)",2
"""import networkx as nx\nimport random\n\ndef tsp_randomized_approximation(graph):\n    # Randomized approximation algorithm for TSP\n    nodes = list(graph.nodes())\n    random.shuffle(nodes)\n    total_cost = 0\n    route = [nodes[0]]\n    for i in range(1, len(nodes)):\n        total_cost += graph[nodes[i - 1]][nodes[i]]['weight']\n        route.append(nodes[i])\n    total_cost += graph[route[-1]][route[0]]['weight']\n    return total_cost, route\n\n# Example graph with weighted edges\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 0, 40)])\ncost, route = tsp_randomized_approximation(G)""",2
"""def maximum_cut_brute_force(edges, n):\n    best_cut_value = 0\n    best_partition = None\n    for i in range(1 << n):\n        set_A = {j for j in range(n) if i & (1 << j)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n        if cut_value > best_cut_value:\n            best_cut_value = cut_value\n            best_partition = (set_A, set_B)\n    return best_cut_value, best_partition\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, partition = maximum_cut_brute_force(edges, 4)""",0
"""def maximum_cut_greedy(edges, n):\n    set_A = set()\n    set_B = set(range(n))\n    for node in range(n):\n        if sum(1 for u, v in edges if u == node and v in set_A) > sum(1 for u, v in edges if u == node and v in set_B):\n            set_B.add(node)\n        else:\n            set_A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, part_A, part_B = maximum_cut_greedy(edges, 4)""",0
"""def maximal_independent_set(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = maximal_independent_set(4, edges)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""def independent_set_greedy(n, edges):\n    independent_set = set()\n    sorted_nodes = sorted(range(n), key=lambda node: sum(1 for u, v in edges if u == node or v == node))\n    for node in sorted_nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = independent_set_greedy(4, edges)""",1
"""def tsp_brute_force(cost_matrix):\n    from itertools import permutations\n    n = len(cost_matrix)\n    min_cost = float('inf')\n    best_route = None\n    for route in permutations(range(n)):\n        cost = sum(cost_matrix[route[i]][route[i+1]] for i in range(n-1)) + cost_matrix[route[-1]][route[0]]\n        if cost < min_cost:\n            min_cost = cost\n            best_route = route\n    return min_cost, best_route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\nmin_cost, best_route = tsp_brute_force(cost_matrix)""",2
"""def maximum_cut_heuristic(n, edges):\n    # Heuristic approach for Maximum Cut\n    set_A, set_B = set(), set(range(n))\n    while set_B:\n        node = set_B.pop()\n        if sum(1 for u, v in edges if u == node and v in set_A) > sum(1 for u, v in edges if u == node and v in set_B):\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, set_A, set_B = maximum_cut_heuristic(4, edges)""",0
"""def maximum_cut_random(n, edges):\n    import random\n    # Randomized approach for Maximum Cut\n    set_A, set_B = set(), set()\n    for i in range(n):\n        if random.random() > 0.5:\n            set_A.add(i)\n        else:\n            set_B.add(i)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, set_A, set_B = maximum_cut_random(4, edges)""",0
"""def maximal_independent_set_backtrack(n, edges):\n    # Backtracking approach to find the Maximal Independent Set\n    best_set = set()\n    def backtrack(node, independent_set):\n        nonlocal best_set\n        if node == n:\n            if len(independent_set) > len(best_set):\n                best_set = independent_set.copy()\n            return\n        # Option 1: Include node\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n            backtrack(node + 1, independent_set)\n            independent_set.remove(node)\n        # Option 2: Exclude node\n        backtrack(node + 1, independent_set)\n    backtrack(0, set())\n    return best_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = maximal_independent_set_backtrack(4, edges)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""def maximal_independent_set_approx(n, edges):\n    # Approximation algorithm for MIS\n    independent_set = set()\n    nodes = set(range(n))\n    while nodes:\n        node = nodes.pop()\n        independent_set.add(node)\n        neighbors = {v for u, v in edges if u == node}\n        nodes -= neighbors\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = maximal_independent_set_approx(4, edges)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"def tsp_nearest_neighbor(cost_matrix):\n    # Nearest Neighbor heuristic for TSP\n    n = len(cost_matrix)\n    visited = [False] * n\n    route = [0]\n    visited[0] = True\n    total_cost = 0\n    current = 0\n    for _ in range(n - 1):\n        next_city = min((city for city in range(n) if not visited[city]), key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        visited[next_city] = True\n        current = next_city\n    total_cost += cost_matrix[current][0]\n    return total_cost, route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_nearest_neighbor(cost_matrix)",2
"def tsp_simulated_annealing(cost_matrix):\n    import random, math\n    # Simulated Annealing for TSP\n    n = len(cost_matrix)\n    current_route = list(range(n))\n    random.shuffle(current_route)\n    current_cost = sum(cost_matrix[current_route[i]][current_route[i+1]] for i in range(n-1)) + cost_matrix[current_route[-1]][current_route[0]]\n    temp = 1000\n    cooling_rate = 0.95\n    while temp > 1:\n        new_route = current_route[:]\n        i, j = random.sample(range(n), 2)\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_cost = sum(cost_matrix[new_route[i]][new_route[i+1]] for i in range(n-1)) + cost_matrix[new_route[-1]][new_route[0]]\n        if new_cost < current_cost or math.exp((current_cost - new_cost) / temp) > random.random():\n            current_route = new_route\n            current_cost = new_cost\n        temp *= cooling_rate\n    return current_cost, current_route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_simulated_annealing(cost_matrix)",2
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(n))\n    route = [0]\n    unvisited.remove(0)\n    total_cost = 0\n    current_city = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current_city][city])\n        total_cost += cost_matrix[current_city][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current_city = next_city\n    total_cost += cost_matrix[route[-1]][route[0]]\n    return total_cost, route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_greedy(cost_matrix)",2
"def maximum_cut_quick(edges, n):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B",0
"def maximum_cut_simple(n, edges):\n    set_A, set_B = set(), set()\n    for node in range(n):\n        if node % 2 == 0:\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B",0
"def independent_set_quick(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def independent_set_random(n, edges):\n    from random import shuffle\n    nodes = list(range(n))\n    shuffle(nodes)\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def tsp_approx(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"def tsp_greedy_short(cost_matrix):\n    n = len(cost_matrix)\n    route, total_cost = [0], 0\n    current = 0\n    for _ in range(1, n):\n        next_city = min(range(n), key=lambda city: cost_matrix[current][city] if city not in route else float('inf'))\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"def max_cut_random(edges, n):\n    import random\n    A, B = set(), set()\n    for i in range(n):\n        if random.random() > 0.5:\n            A.add(i)\n        else:\n            B.add(i)\n    return sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A)), A, B",0
"def max_cut_with_weights(edges, n):\n    A, B = set(), set(range(n))\n    cut_value = 0\n    for u, v, w in edges:\n        if (u in A and v in B) or (u in B and v in A):\n            cut_value += w\n    return cut_value, A, B",0
"def max_cut_bitmask(edges, n):\n    best_cut, best_partition = 0, None\n    for i in range(1 << n):\n        A = {j for j in range(n) if i & (1 << j)}\n        B = set(range(n)) - A\n        cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n        if cut_value > best_cut:\n            best_cut, best_partition = cut_value, (A, B)\n    return best_cut, best_partition",0
"def max_cut_alternate_assignment(edges, n):\n    A, B = set(), set()\n    for i in range(n):\n        if i % 2 == 0:\n            A.add(i)\n        else:\n            B.add(i)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B",0
"def max_cut_nearest_neighbor(edges, n):\n    A, B = {0}, set(range(1, n))\n    for u, v in edges:\n        if u in A and v in B:\n            B.remove(v)\n            A.add(v)\n        elif u in B and v in A:\n            A.remove(v)\n            B.add(v)\n    return sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A)), A, B",0
"def independent_set_random(n, edges):\n    from random import shuffle\n    nodes = list(range(n))\n    shuffle(nodes)\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def independent_set_backtracking(n, edges):\n    def is_valid(independent_set, node):\n        return all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, independent_set):\n        if node == n:\n            return independent_set\n        if is_valid(independent_set, node):\n            new_set = independent_set.copy()\n            new_set.add(node)\n            return backtrack(node + 1, new_set)\n        return backtrack(node + 1, independent_set)\n    return backtrack(0, set())",1
"def independent_set_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    sorted_nodes = sorted(range(n), key=lambda x: degree[x])\n    independent_set = set()\n    for node in sorted_nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def independent_set_greedy(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def independent_set_greedy_weighted(n, edges, weights):\n    independent_set = set()\n    for node in sorted(range(n), key=lambda x: weights[x]):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def tsp_dynamic_programming(cost_matrix):\n    n = len(cost_matrix)\n    dp = [[float('inf')] * (1 << n) for _ in range(n)]\n    dp[0][1] = 0\n    for mask in range(1 << n):\n        for u in range(n):\n            if not (mask & (1 << u)):\n                continue\n            for v in range(n):\n                if mask & (1 << v):\n                    dp[v][mask] = min(dp[v][mask], dp[u][mask ^ (1 << v)] + cost_matrix[u][v])\n    return min(dp[i][(1 << n) - 1] + cost_matrix[i][0] for i in range(1, n))",2
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"def tsp_nearest_neighbor(cost_matrix):\n    n = len(cost_matrix)\n    visited = [False] * n\n    route = [0]\n    visited[0] = True\n    total_cost = 0\n    current = 0\n    for _ in range(n - 1):\n        next_city = min((city for city in range(n) if not visited[city]), key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        visited[next_city] = True\n        current = next_city\n    total_cost += cost_matrix[current][0]\n    return total_cost, route",2
"def tsp_simulated_annealing(cost_matrix):\n    import random, math\n    n = len(cost_matrix)\n    current_route = list(range(n))\n    random.shuffle(current_route)\n    current_cost = sum(cost_matrix[current_route[i]][current_route[i+1]] for i in range(n-1)) + cost_matrix[current_route[-1]][current_route[0]]\n    temp = 1000\n    cooling_rate = 0.95\n    while temp > 1:\n        new_route = current_route[:]\n        i, j = random.sample(range(n), 2)\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_cost = sum(cost_matrix[new_route[i]][new_route[i+1]] for i in range(n-1)) + cost_matrix[new_route[-1]][new_route[0]]\n        if new_cost < current_cost or math.exp((current_cost - new_cost) / temp) > random.random():\n            current_route = new_route\n            current_cost = new_cost\n        temp *= cooling_rate\n    return current_cost, current_route",2
"def tsp_approx(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"import networkx as nx\n\ndef maximum_cut_greedy_networkx(G):\n    set_A, set_B = set(), set(G.nodes)\n    for node in G.nodes:\n        if sum(1 for neighbor in G.neighbors(node) if neighbor in set_A) > sum(1 for neighbor in G.neighbors(node) if neighbor in set_B):\n            set_B.add(node)\n        else:\n            set_A.add(node)\n    cut_value = sum(1 for u, v in G.edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nmaximum_cut_greedy_networkx(G)",0
"def maximum_cut_randomized(edges, n):\n    import random\n    set_A, set_B = set(), set()\n    for i in range(n):\n        if random.random() > 0.5:\n            set_A.add(i)\n        else:\n            set_B.add(i)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in B and v in A)), set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nmaximum_cut_randomized(edges, 4)",0
"def maximum_cut_bitmask(edges, n):\n    best_cut, best_partition = 0, None\n    for mask in range(1 << n):\n        set_A = {i for i in range(n) if mask & (1 << i)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in B and v in A))\n        if cut_value > best_cut:\n            best_cut, best_partition = cut_value, (set_A, set_B)\n    return best_cut, best_partition",0
"def maximum_cut_degree_based(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    A, B = set(), set()\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        if len(A) <= len(B):\n            A.add(node)\n        else:\n            B.add(node)\n    return sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A)), A, B",0
"import networkx as nx\n\ndef maximum_cut_brute_force_networkx(G):\n    from itertools import combinations\n    best_cut = 0\n    best_partition = None\n    for cut in combinations(G.nodes, len(G)//2):\n        A = set(cut)\n        B = set(G.nodes) - A\n        cut_value = sum(1 for u, v in G.edges if (u in A and v in B) or (u in B and v in A))\n        if cut_value > best_cut:\n            best_cut = cut_value\n            best_partition = A, B\n    return best_cut, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nmaximum_cut_brute_force_networkx(G)",0
"import networkx as nx\n\ndef independent_set_greedy_networkx(G):\n    independent_set = set()\n    for node in G.nodes:\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nindependent_set_greedy_networkx(G)",1
"def independent_set_greedy(edges, n):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_greedy(edges, 4)",1
"def independent_set_random(n, edges):\n    from random import shuffle\n    nodes = list(range(n))\n    shuffle(nodes)\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_random(n, edges)",1
"import networkx as nx\n\ndef independent_set_backtracking_networkx(G):\n    def is_valid_set(independent_set, node):\n        return all(neighbor not in independent_set for neighbor in G.neighbors(node))\n    def backtrack(node, independent_set):\n        if node == len(G):\n            return independent_set\n        if is_valid_set(independent_set, node):\n            new_set = independent_set.copy()\n            new_set.add(node)\n            return backtrack(node + 1, new_set)\n        return backtrack(node + 1, independent_set)\n    return backtrack(0, set())\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nindependent_set_backtracking_networkx(G)",1
"def independent_set_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    independent_set = set()\n    for node in sorted(range(n), key=lambda x: degree[x]):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_degree_heuristic(n, edges)",1
"import networkx as nx\n\ndef tsp_brute_force_networkx(G):\n    from itertools import permutations\n    best_cost = float('inf')\n    best_route = None\n    for route in permutations(G.nodes):\n        cost = sum(G[route[i]][route[i+1]]['weight'] for i in range(len(route) - 1)) + G[route[-1]][route[0]]['weight']\n        if cost < best_cost:\n            best_cost = cost\n            best_route = route\n    return best_cost, best_route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\ntsp_brute_force_networkx(G)",2
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ntsp_greedy(cost_matrix)",2
"def tsp_simulated_annealing(cost_matrix):\n    import random, math\n    n = len(cost_matrix)\n    current_route = list(range(n))\n    random.shuffle(current_route)\n    current_cost = sum(cost_matrix[current_route[i]][current_route[i+1]] for i in range(n-1)) + cost_matrix[current_route[-1]][current_route[0]]\n    temp = 1000\n    cooling_rate = 0.95\n    while temp > 1:\n        new_route = current_route[:]\n        i, j = random.sample(range(n), 2)\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_cost = sum(cost_matrix[new_route[i]][new_route[i+1]] for i in range(n-1)) + cost_matrix[new_route[-1]][new_route[0]]\n        if new_cost < current_cost or math.exp((current_cost - new_cost) / temp) > random.random():\n            current_route = new_route\n            current_cost = new_cost\n        temp *= cooling_rate\n    return current_cost, current_route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ntsp_simulated_annealing(cost_matrix)",2
"import networkx as nx\n\ndef tsp_nearest_neighbor_networkx(G):\n    visited = [False] * len(G)\n    route = [0]\n    visited[0] = True\n    total_cost = 0\n    current = 0\n    for _ in range(len(G) - 1):\n        next_city = min((city for city in range(len(G)) if not visited[city]), key=lambda city: G[current][city]['weight'])\n        total_cost += G[current][next_city]['weight']\n        route.append(next_city)\n        visited[next_city] = True\n        current = next_city\n    total_cost += G[route[-1]][route[0]]['weight']\n    return total_cost, route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\ntsp_nearest_neighbor_networkx(G)",2
"def clique_brute_force(n, edges):\n    from itertools import combinations\n    max_clique = []\n    for k in range(2, n+1):\n        for subset in combinations(range(n), k):\n            if all((u, v) in edges or (v, u) in edges for u in subset for v in subset if u != v):\n                if len(subset) > len(max_clique):\n                    max_clique = subset\n    return max_clique",3
"def clique_greedy(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique",3
"import networkx as nx\n\ndef clique_networkx_brute_force(G):\n    from itertools import combinations\n    max_clique = []\n    nodes = list(G.nodes())\n    for k in range(2, len(nodes) + 1):\n        for subset in combinations(nodes, k):\n            if G.subgraph(subset).number_of_edges() == len(subset) * (len(subset) - 1) // 2:\n                if len(subset) > len(max_clique):\n                    max_clique = subset\n    return max_clique\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nclique_networkx_brute_force(G)",3
"def clique_greedy_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    clique = set()\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique",3
"def clique_randomized(n, edges):\n    import random\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    clique = set()\n    for node in nodes:\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique",3
"import networkx as nx\n\ndef clique_networkx_greedy(G):\n    clique = set()\n    for node in G.nodes():\n        if all(neighbor in clique or (G.has_edge(node, neighbor)) for neighbor in G.neighbors(node)):\n            clique.add(node)\n    return clique\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nclique_networkx_greedy(G)",3
"def clique_bitmask(n, edges):\n    max_clique = []\n    for mask in range(1 << n):\n        subset = [i for i in range(n) if mask & (1 << i)]\n        if all((u, v) in edges or (v, u) in edges for u in subset for v in subset if u != v):\n            if len(subset) > len(max_clique):\n                max_clique = subset\n    return max_clique",3
"def clique_backtracking(n, edges):\n    def is_clique(nodes):\n        return all((u, v) in edges or (v, u) in edges for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == n:\n            return current_clique\n        if is_clique(current_clique + [node]):\n            with_node = backtrack(node + 1, current_clique + [node])\n            without_node = backtrack(node + 1, current_clique)\n            return max(with_node, without_node, key=len)\n        return backtrack(node + 1, current_clique)\n    return backtrack(0, [])",3
"import networkx as nx\n\ndef clique_networkx_backtracking(G):\n    def is_clique(nodes):\n        return all(G.has_edge(u, v) for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == len(G.nodes):\n            return current_clique\n        if is_clique(current_clique + [node]):\n            with_node = backtrack(node + 1, current_clique + [node])\n            without_node = backtrack(node + 1, current_clique)\n            return max(with_node, without_node, key=len)\n        return backtrack(node + 1, current_clique)\n    return backtrack(0, [])\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nclique_networkx_backtracking(G)",3
"def clique_approximate(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique",3
"def kcoloring_backtracking(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_backtracking(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy(G, k):\n    colors = {}\n    for node in G.nodes():\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_greedy(G, 3)",4
"def kcoloring_random(n, edges, k):\n    import random\n    colors = [-1] * n\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    for node in nodes:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v] if colors[neighbor] != -1}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_random(4, edges, 3)",4
"def kcoloring_greedy_degree_heuristic(n, edges, k):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    colors = [-1] * n\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_greedy_degree_heuristic(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_backtracking(G, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for neighbor in G.neighbors(node))\n    def backtrack(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * len(G.nodes))\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_backtracking(G, 3)",4
"def kcoloring_min_conflict(n, edges, k, max_steps=1000):\n    import random\n    colors = [random.choice(range(k)) for _ in range(n)]\n    def count_conflicts(node):\n        return sum(1 for u, v in edges if u == node and colors[v] == colors[u])\n    for _ in range(max_steps):\n        conflicted = [node for node in range(n) if count_conflicts(node) > 0]\n        if not conflicted:\n            return colors\n        node = random.choice(conflicted)\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return None\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_min_conflict(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy_degree(G, k):\n    degree = {i: len(list(G.neighbors(i))) for i in G.nodes}\n    colors = {}\n    for node in sorted(G.nodes(), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_greedy_degree(G, 3)",4
"def kcoloring_sequential(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_sequential(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_min_conflict(G, k):\n    import random\n    colors = {node: random.choice(range(k)) for node in G.nodes()}\n    def count_conflicts(node):\n        return sum(1 for neighbor in G.neighbors(node) if colors[neighbor] == colors[node])\n    for _ in range(1000):\n        conflicted = [node for node in G.nodes() if count_conflicts(node) > 0]\n        if not conflicted:\n            return colors\n        node = random.choice(conflicted)\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node)}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return None\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_min_conflict(G, 3)",4
"def kcoloring_dfs(n, edges, k):\n    def dfs(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v]):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * n)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_dfs(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_dfs(G, k):\n    def dfs(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for neighbor in G.neighbors(node)):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * len(G.nodes))\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_dfs(G, 3)",4
"def kcoloring_backtracking(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_backtracking(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy(G, k):\n    colors = {}\n    for node in G.nodes():\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_greedy(G, 3)\nprint(colors)",4
"def kcoloring_random(n, edges, k):\n    import random\n    colors = [-1] * n\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    for node in nodes:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v] if colors[neighbor] != -1}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_random(4, edges, 3)\nprint(colors)",4
"def kcoloring_sequential(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_sequential(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_backtracking(G, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for neighbor in G.neighbors(node))\n    def backtrack(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * len(G.nodes))\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_backtracking(G, 3)\nprint(colors)",4
"def kcoloring_greedy_degree_heuristic(n, edges, k):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    colors = [-1] * n\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_greedy_degree_heuristic(4, edges, 3)\nprint(colors)",4
"def kcoloring_dfs(n, edges, k):\n    def dfs(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v]):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * n)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_dfs(4, edges, 3)\nprint(colors)",4
"import random\n\ndef kcoloring_simulated_annealing(n, edges, k, max_steps=1000):\n    colors = [random.choice(range(k)) for _ in range(n)]\n    temperature = 1000\n    def count_conflicts():\n        return sum(1 for u, v in edges if colors[u] == colors[v])\n    for _ in range(max_steps):\n        if count_conflicts() == 0:\n            return colors\n        node = random.choice(range(n))\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            new_color = random.choice(list(available_colors))\n            current_conflicts = count_conflicts()\n            colors[node] = new_color\n            if count_conflicts() >= current_conflicts and random.random() > (1.0 / temperature):\n                colors[node] = new_color  # Revert to previous\n        temperature *= 0.95\n    return None\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_simulated_annealing(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_dfs(G, k):\n    def dfs(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for neighbor in G.neighbors(node)):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * len(G.nodes))\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_dfs(G, 3)\nprint(colors)",4
"def kcoloring_custom_order(n, edges, k):\n    custom_order = [0, 3, 1, 2]  # Some arbitrary custom order\n    colors = [-1] * n\n    for node in custom_order:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_custom_order(4, edges, 3)\nprint(colors)",4
"def max_cut_brute_force(edges, n):\n    best_cut_value = 0\n    best_partition = None\n    for i in range(1 << n):\n        set_A = {j for j in range(n) if i & (1 << j)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n        if cut_value > best_cut_value:\n            best_cut_value = cut_value\n            best_partition = (set_A, set_B)\n    return best_cut_value, best_partition\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, partition = max_cut_brute_force(edges, 4)\nprint(cut_value, partition)",0
"def max_cut_random(n, edges):\n    import random\n    set_A, set_B = set(), set()\n    for node in range(n):\n        if random.random() > 0.5:\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, part_A, part_B = max_cut_random(4, edges)\nprint(cut_value, part_A, part_B)",0
"def mis_greedy(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = mis_greedy(4, edges)\nprint(independent_set)",1
"def mis_backtracking(n, edges):\n    def is_valid(independent_set, node):\n        return all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, current_set):\n        if node == n:\n            return current_set\n        with_node = backtrack(node + 1, current_set + [node]) if is_valid(current_set, node) else []\n        without_node = backtrack(node + 1, current_set)\n        return max(with_node, without_node, key=len)\n    return backtrack(0, [])\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = mis_backtracking(4, edges)\nprint(independent_set)",1
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_greedy(cost_matrix)\nprint(cost, route)",2
"def tsp_brute_force(cost_matrix):\n    from itertools import permutations\n    n = len(cost_matrix)\n    min_cost = float('inf')\n    best_route = None\n    for route in permutations(range(n)):\n        cost = sum(cost_matrix[route[i]][route[i+1]] for i in range(n-1)) + cost_matrix[route[-1]][route[0]]\n        if cost < min_cost:\n            min_cost = cost\n            best_route = route\n    return min_cost, best_route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\nmin_cost, route = tsp_brute_force(cost_matrix)\nprint(min_cost, route)",2
"def clique_backtracking(n, edges):\n    def is_clique(nodes):\n        return all((u, v) in edges or (v, u) in edges for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == n:\n            return current_clique\n        with_node = backtrack(node + 1, current_clique + [node]) if is_clique(current_clique + [node]) else []\n        without_node = backtrack(node + 1, current_clique)\n        return max(with_node, without_node, key=len)\n    return backtrack(0, [])\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)]\nclique = clique_backtracking(4, edges)\nprint(clique)",3
"def clique_greedy(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)]\nclique = clique_greedy(4, edges)\nprint(clique)",3
"def kcoloring_greedy(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_greedy(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy(G, k):\n    colors = {}\n    for node in G.nodes():\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_greedy(G, 3)\nprint(colors)",4
"def trial_division_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 56\nfactors = trial_division_factorization(n)\nprint(factors)",5
"def fermat_factorization(n):\n    if n % 2 == 0:\n        return [2, n // 2]\n    a = int(n**0.5) + 1\n    b2 = a*a - n\n    while int(b2**0.5)**2 != b2:\n        a += 1\n        b2 = a*a - n\n    b = int(b2**0.5)\n    return [a - b, a + b]\n\n# Input data\nn = 5959\nfactors = fermat_factorization(n)\nprint(factors)",5
"def pollard_rho_factorization(n):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    def f(x):\n        return (x*x + 1) % n\n    x, y, d = 2, 2, 1\n    while d == 1:\n        x = f(x)\n        y = f(f(y))\n        d = gcd(abs(x - y), n)\n    if d == n:\n        return None\n    return [d, n // d]\n\n# Input data\nn = 8051\nfactors = pollard_rho_factorization(n)\nprint(factors)",5
"def naive_factorization(n):\n    factors = []\n    for i in range(2, n + 1):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    return factors\n\n# Input data\nn = 315\nfactors = naive_factorization(n)\nprint(factors)",5
"def pollard_rho_optimized(n):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    def f(x):\n        return (x * x + 1) % n\n    x, y, d = 2, 2, 1\n    while d == 1:\n        x = f(x)\n        y = f(f(y))\n        d = gcd(abs(x - y), n)\n    if d == n:\n        return None\n    return [d, n // d]\n\n# Input data\nn = 10403\nfactors = pollard_rho_optimized(n)\nprint(factors)",5
"def pollard_brent_factorization(n):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    y, c, m = 2, 1, 100\n    g, r, q = 1, 1, 1\n    x, ys = 0, 0\n    while g == 1:\n        x = y\n        for i in range(r):\n            y = (y * y + c) % n\n        k = 0\n        while k < r and g == 1:\n            ys = y\n            for i in range(min(m, r - k)):\n                y = (y * y + c) % n\n                q = q * abs(x - y) % n\n            g = gcd(q, n)\n            k += m\n        r *= 2\n    if g == n:\n        while True:\n            ys = (ys * ys + c) % n\n            g = gcd(abs(x - ys), n)\n            if g > 1:\n                break\n    return [g, n // g]\n\n# Input data\nn = 5897\nfactors = pollard_brent_factorization(n)\nprint(factors)",5
"def fermat_modified_factorization(n):\n    if n % 2 == 0:\n        return [2, n // 2]\n    x = int(n**0.5) + 1\n    while True:\n        y2 = x*x - n\n        y = int(y2**0.5)\n        if y*y == y2:\n            break\n        x += 1\n    return [x - y, x + y]\n\n# Input data\nn = 1369\nfactors = fermat_modified_factorization(n)\nprint(factors)",5
"def optimized_trial_division(n):\n    factors = []\n    divisor = 2\n    while n % divisor == 0:\n        factors.append(divisor)\n        n //= divisor\n    divisor = 3\n    while n > 1 and divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 2\n    if n > 1:\n        factors.append(n)\n    return factors\n\n# Input data\nn = 123456\nfactors = optimized_trial_division(n)\nprint(factors)",5
"def simple_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 1458\nfactors = simple_factorization(n)\nprint(factors)",5
"def factorization_recursive(n):\n    def recursive_division(n, divisor=2):\n        if n == 1:\n            return []\n        if n % divisor == 0:\n            return [divisor] + recursive_division(n // divisor, divisor)\n        return recursive_division(n, divisor + 1)\n    return recursive_division(n)\n\n# Input data\nn = 98\nfactors = factorization_recursive(n)\nprint(factors)",5
"def wheel_factorization(n):\n    factors = []\n    wheel = [2, 3, 5]\n    for prime in wheel:\n        while n % prime == 0:\n            factors.append(prime)\n            n //= prime\n    divisor = 7\n    step = [4, 2, 4, 2, 4, 6, 2, 6]\n    while divisor * divisor <= n:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += step.pop(0)\n            step.append(step[-1])\n    if n > 1:\n        factors.append(n)\n    return factors\n\n# Input data\nn = 2310\nfactors = wheel_factorization(n)\nprint(factors)",5
"def rho_with_random_pollard(n):\n    from random import randint\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    def f(x, n):\n        return (x*x + randint(1, 10)) % n\n    x, y, d = 2, 2, 1\n    while d == 1:\n        x = f(x, n)\n        y = f(f(y, n), n)\n        d = gcd(abs(x - y), n)\n    if d == n:\n        return None\n    return [d, n // d]\n\n# Input data\nn = 8893\nfactors = rho_with_random_pollard(n)\nprint(factors)",5
"""# Python code\nimport networkx as nx\n\ndef priority_based_mis(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: (G.degree(x), x))\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = priority_based_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")""",1
"""# Python code\nimport networkx as nx\n\ndef greedy_degree_mis(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x), reverse=True)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = greedy_degree_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")""",1
"""# Python code\nimport networkx as nx\n\ndef recursive_heuristic_mis(G, independent_set=None, remaining_nodes=None):\n    if independent_set is None:\n        independent_set = set()\n    if remaining_nodes is None:\n        remaining_nodes = set(G.nodes())\n    if not remaining_nodes:\n        return independent_set\n    node = min(remaining_nodes, key=lambda x: G.degree(x))\n    neighbors = set(G.neighbors(node))\n    new_set = independent_set | {node}\n    return recursive_heuristic_mis(G, new_set, remaining_nodes - neighbors)\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = recursive_heuristic_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")""",1
"""# Python code\nimport networkx as nx\n\ndef depth_first_mis(G):\n    independent_set = set()\n    visited_nodes = set()\n    def dfs(node):\n        if node not in visited_nodes:\n            visited_nodes.add(node)\n            independent_set.add(node)\n            for neighbor in G.neighbors(node):\n                visited_nodes.add(neighbor)\n    for start_node in G.nodes():\n        dfs(start_node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 5), (5, 6), (6, 1)])\nresult_set = depth_first_mis(G)\nprint(f""Maximal Independent Set: {result_set}"")""",1
"""# Python code\nimport networkx as nx\nimport random\n\ndef shuffled_greedy_mis(G):\n    independent_set = set()\n    nodes = list(G.nodes())\n    random.shuffle(nodes)\n    for node in nodes:\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 2), (2, 3), (3, 5), (5, 6), (6, 0)])\nmis_set = shuffled_greedy_mis(G)\nprint(f""Maximal Independent Set: {mis_set}"")""",1
"""# Python code\nimport networkx as nx\nimport random\n\ndef random_degree_priority_mis(G):\n    independent_set = set()\n    nodes = sorted(G.nodes(), key=lambda n: G.degree(n), reverse=True)\n    random.shuffle(nodes)\n    while nodes:\n        node = nodes.pop(0)\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 4), (4, 5), (5, 3), (3, 1)])\nmis_set = random_degree_priority_mis(G)\nprint(f""Maximal Independent Set: {mis_set}"")"" ",1
"""# Python code\nimport networkx as nx\nimport random\n\ndef random_degree_priority_mis(G):\n    independent_set = set()\n    nodes = sorted(G.nodes(), key=lambda n: G.degree(n), reverse=True)\n    random.shuffle(nodes)\n    while nodes:\n        node = nodes.pop(0)\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 4), (4, 5), (5, 3), (3, 1)])\nmis_set = random_degree_priority_mis(G)\nprint(f""Maximal Independent Set: {mis_set}"")"" ",1
"""import networkx as nx\n\ndef recursive_mis(graph, current_set=None, remaining=None):\n    if current_set is None:\n        current_set = set()\n    if remaining is None:\n        remaining = set(graph.nodes())\n    if not remaining:\n        return current_set\n    node = remaining.pop()\n    neighbors = set(graph.neighbors(node))\n    new_set = current_set | {node}\n    return recursive_mis(graph, new_set, remaining - neighbors)\n\ngraph = nx.Graph()\ngraph.add_edges_from([(0, 2), (2, 3), (3, 1), (1, 0)])\nresult = recursive_mis(graph)\nprint(f""Maximal Independent Set: {result}"")"" ",1
"""# Python code\nimport networkx as nx\nimport random\n\ndef randomized_maxcut_random(G, iterations=500):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n        if cut_value > max_cut_value:\n            max_cut_value = cut_value\n            best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 4), (4, 3), (3, 0)])\nmax_cut, best_part = randomized_maxcut_random(G)\nprint(f""Maximum Cut: {max_cut}"")\nprint(f""Best Partition: {best_part}"")"" ",0
"""# Python code\nimport networkx as nx\n\ndef greedy_maxcut_simple(G):\n    partition_A = set()\n    partition_B = set(G.nodes())\n    for node in G.nodes():\n        if sum(1 for neighbor in G.neighbors(node) if neighbor in partition_A) > sum(1 for neighbor in G.neighbors(node) if neighbor in partition_B):\n            partition_B.add(node)\n        else:\n            partition_A.add(node)\n    max_cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return max_cut_value, partition_A, partition_B\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value, part_A, part_B = greedy_maxcut_simple(G)\nprint(f""Maximum Cut Value: {cut_value}"")"" ",0
"# Python code\nimport networkx as nx\n\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = maximum_cut(G)\nprint(result)",1
"""import networkx as nx\nimport random\n\ndef randomized_maxcut(G, iterations=1000):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nmax_cut_value, best_partition = randomized_maxcut(G)\nprint(f\""Maximum cut value: {max_cut_value}\"")\nprint(f\""Best partition: {best_partition}\"")""",1
"""# Python code\nimport networkx as nx\n\ndef independent_set(G):\n    independent_set = set()\n    for node in G.nodes():\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = independent_set(G)\nprint(f\""Independent Set: {result}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef maximum_cut_randomized(G):\n    # Randomized approach for solving Maximum Cut\n    import random\n    partition_A = set(random.sample(G.nodes(), len(G.nodes()) // 2))\n    partition_B = set(G.nodes()) - partition_A\n    cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)])\ncut_value = maximum_cut_randomized(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef independent_set_heuristic(G):\n    # Use heuristic approach to find independent set\n    independent_set = set()\n    for node in G.nodes():\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 2)])\nresult = independent_set_heuristic(G)\nprint(f\""Independent Set: {result}\"")""",1
"""import networkx as nx\n\ndef max_cut_using_simulated_annealing(G):\n    # Simulated Annealing approach for Maximum Cut\n    import random, math\n    nodes = list(G.nodes())\n    curr_sol = set(random.sample(nodes, len(nodes) // 2))\n    best_sol = curr_sol\n    cut_val = calc_cut_value(G, curr_sol)\n    temp = 1000\n    while temp > 1:\n        new_sol = curr_sol.copy()\n        node = random.choice(list(new_sol))\n        new_sol.remove(node)\n        new_cut_val = calc_cut_value(G, new_sol)\n        if new_cut_val > cut_val or math.exp((new_cut_val - cut_val) / temp) > random.random():\n            curr_sol = new_sol\n            cut_val = new_cut_val\n            best_sol = curr_sol\n        temp *= 0.95\n    return cut_val, best_sol\n\ndef calc_cut_value(G, partition_A):\n    partition_B = set(G.nodes()) - partition_A\n    return sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 2)])\ncut_value, partition = max_cut_using_simulated_annealing(G)\n""",0
"""# Python code\nimport networkx as nx\n\ndef greedy_maximum_cut_algo(graph):\n    # Greedy solution to solve the Maximum Cut\n    A = set()\n    B = set(graph.nodes())\n    for n in graph.nodes():\n        if sum(1 for neighbor in graph.neighbors(n) if neighbor in A) > sum(1 for neighbor in graph.neighbors(n) if neighbor in B):\n            B.add(n)\n        else:\n            A.add(n)\n    cut_value = sum(1 for u, v in graph.edges() if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value, A, B = greedy_maximum_cut_algo(G)\nprint(f\""Max Cut: {cut_value}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef maximal_independent_set_dfs(graph):\n    # DFS approach to find maximal independent set\n    i_set = set()\n    visited = set()\n    def dfs(node):\n        if node not in visited:\n            visited.add(node)\n            i_set.add(node)\n            for neighbor in graph.neighbors(node):\n                visited.add(neighbor)\n    for start_node in graph.nodes():\n        dfs(start_node)\n    return i_set\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 5), (5, 0)])\nindependent_set = maximal_independent_set_dfs(G)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""# Python code\nimport networkx as nx\n\ndef randomized_independent_set_algorithm(G):\n    # Use randomized approach to find independent set\n    import random\n    independent_set = set()\n    remaining_nodes = list(G.nodes())\n    random.shuffle(remaining_nodes)\n    for node in remaining_nodes:\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = randomized_independent_set_algorithm(G)\nprint(f\""Independent Set: {result}\"")""",1
"""import networkx as nx\nfrom itertools import permutations\n\ndef tsp_brute_force(graph):\n    # Brute-force solution for TSP\n    nodes = list(graph.nodes())\n    min_cost = float('inf')\n    best_route = None\n    for route in permutations(nodes):\n        cost = sum(graph[route[i]][route[i+1]]['weight'] for i in range(len(route) - 1)) + graph[route[-1]][route[0]]['weight']\n        if cost < min_cost:\n            min_cost = cost\n            best_route = route\n    return min_cost, best_route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 8), (1, 2, 12), (2, 3, 15), (3, 0, 9)])\nmin_cost, route = tsp_brute_force(G)",2
"""# Python code\nimport networkx as nx\nimport random\n\ndef tsp_greedy(graph):\n    # Greedy algorithm for TSP\n    start_node = random.choice(list(graph.nodes()))\n    unvisited = set(graph.nodes())\n    unvisited.remove(start_node)\n    route = [start_node]\n    current_node = start_node\n    total_cost = 0\n    while unvisited:\n        next_node = min(unvisited, key=lambda node: graph[current_node][node]['weight'])\n        total_cost += graph[current_node][next_node]['weight']\n        route.append(next_node)\n        unvisited.remove(next_node)\n        current_node = next_node\n    total_cost += graph[route[-1]][route[0]]['weight']\n    return total_cost, route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 11), (1, 2, 9), (2, 3, 14), (3, 0, 12)])\ncost, route = tsp_greedy(G)",2
"""def maximum_cut_heuristic(n, edges):\n    set_A, set_B = set(), set(range(n))\n    while set_B:\n        node = set_B.pop()\n        if sum(1 for u, v in edges if u == node and v in set_A) > sum(1 for u, v in edges if u == node and v in set_B):\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, set_A, set_B = maximum_cut_heuristic(4, edges)""",0
"""def maximal_independent_set_approx(n, edges):\n    independent_set = set()\n    nodes = set(range(n))\n    while nodes:\n        node = nodes.pop()\n        independent_set.add(node)\n        neighbors = {v for u, v in edges if u == node}\n        nodes -= neighbors\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = maximal_independent_set_approx(4, edges)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""def tsp_simulated_annealing(cost_matrix):\n    import random, math\n    n = len(cost_matrix)\n    current_route = list(range(n))\n    random.shuffle(current_route)\n    current_cost = sum(cost_matrix[current_route[i]][current_route[i+1]] for i in range(n-1)) + cost_matrix[current_route[-1]][current_route[0]]\n    temp = 1000\n    cooling_rate = 0.95\n    while temp > 1:\n        new_route = current_route[:]\n        i, j = random.sample(range(n), 2)\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_cost = sum(cost_matrix[new_route[i]][new_route[i+1]] for i in range(n-1)) + cost_matrix[new_route[-1]][new_route[0]]\n        if new_cost < current_cost or math.exp((current_cost - new_cost) / temp) > random.random():\n            current_route = new_route\n            current_cost = new_cost\n        temp *= cooling_rate\n    return current_cost, current_route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_simulated_annealing(cost_matrix)""",2
"def maximum_cut_quick(edges, n):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B",0
"def independent_set_quick(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def tsp_approx(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"import networkx as nx\n\ndef maximum_cut_greedy_networkx(G):\n    set_A, set_B = set(), set(G.nodes)\n    for node in G.nodes:\n        if sum(1 for neighbor in G.neighbors(node) if neighbor in set_A) > sum(1 for neighbor in G.neighbors(node) if neighbor in set_B):\n            set_B.add(node)\n        else:\n            set_A.add(node)\n    cut_value = sum(1 for u, v in G.edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nmaximum_cut_greedy_networkx(G)",0
"def maximum_cut_randomized(edges, n):\n    import random\n    set_A, set_B = set(), set()\n    for i in range(n):\n        if random.random() > 0.5:\n            set_A.add(i)\n        else:\n            set_B.add(i)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A)), set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nmaximum_cut_randomized(edges, 4)",0
"import networkx as nx\n\ndef independent_set_greedy_networkx(G):\n    independent_set = set()\n    for node in G.nodes:\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nindependent_set_greedy_networkx(G)",1
"def independent_set_random(n, edges):\n    from random import shuffle\n    nodes = list(range(n))\n    shuffle(nodes)\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_random(n, edges)",1
"import networkx as nx\n\ndef tsp_brute_force_networkx(G):\n    from itertools import permutations\n    best_cost = float('inf')\n    best_route = None\n    for route in permutations(G.nodes):\n        cost = sum(G[route[i]][route[i+1]]['weight'] for i in range(len(route) - 1)) + G[route[-1]][route[0]]['weight']\n        if cost < best_cost:\n            best_cost = cost\n            best_route = route\n    return best_cost, best_route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\ntsp_brute_force_networkx(G)",2
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ntsp_greedy(cost_matrix)",2
"import networkx as nx\n\ndef tsp_nearest_neighbor_networkx(G):\n    visited = [False] * len(G)\n    route = [0]\n    visited[0] = True\n    total_cost = 0\n    current = 0\n    for _ in range(len(G) - 1):\n        next_city = min((city for city in range(len(G)) if not visited[city]), key=lambda city: G[current][city]['weight'])\n        total_cost += G[current][next_city]['weight']\n        route.append(next_city)\n        visited[next_city] = True\n        current = next_city\n    total_cost += G[route[-1]][route[0]]['weight']\n    return total_cost, route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\ntsp_nearest_neighbor_networkx(G)",2
"def independent_set_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    independent_set = set()\n    for node in sorted(range(n), key=lambda x: degree[x]):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_degree_heuristic(n, edges)",1
"def clique_brute_force(n, edges):\n    from itertools import combinations\n    max_clique = []\n    for k in range(2, n+1):\n        for subset in combinations(range(n), k):\n            if all((u, v) in edges or (v, u) in edges for u in subset for v in subset if u != v):\n                if len(subset) > len(max_clique):\n                    max_clique = subset\n    return max_clique",3
"import networkx as nx\n\ndef clique_networkx_greedy(G):\n    clique = set()\n    for node in G.nodes():\n        if all(neighbor in clique or (G.has_edge(node, neighbor)) for neighbor in G.neighbors(node)):\n            clique.add(node)\n    return clique\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nclique_networkx_greedy(G)",3
"def clique_greedy_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    clique = set()\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_greedy_degree_heuristic(4, edges)",3
"def clique_bitmask(n, edges):\n    max_clique = []\n    for mask in range(1 << n):\n        subset = [i for i in range(n) if mask & (1 << i)]\n        if all((u, v) in edges or (v, u) in edges for u in subset for v in subset if u != v):\n            if len(subset) > len(max_clique):\n                max_clique = subset\n    return max_clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_bitmask(4, edges)",3
"import networkx as nx\n\ndef clique_networkx_backtracking(G):\n    def is_clique(nodes):\n        return all(G.has_edge(u, v) for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == len(G.nodes):\n            return current_clique\n        if is_clique(current_clique + [node]):\n            with_node = backtrack(node + 1, current_clique + [node])\n            without_node = backtrack(node + 1, current_clique)\n            return max(with_node, without_node, key=len)\n        return backtrack(node + 1, current_clique)\n    return backtrack(0, [])\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nclique_networkx_backtracking(G)",3
"def clique_approximate(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_approximate(4, edges)",3
"def clique_backtracking(n, edges):\n    def is_clique(nodes):\n        return all((u, v) in edges or (v, u) in edges for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == n:\n            return current_clique\n        if is_clique(current_clique + [node]):\n            with_node = backtrack(node + 1, current_clique + [node])\n            without_node = backtrack(node + 1, current_clique)\n            return max(with_node, without_node, key=len)\n        return backtrack(node + 1, current_clique)\n    return backtrack(0, [])\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_backtracking(4, edges)",3
"import networkx as nx\n\ndef clique_networkx_brute_force(G):\n    from itertools import combinations\n    max_clique = []\n    nodes = list(G.nodes())\n    for k in range(2, len(nodes) + 1):\n        for subset in combinations(nodes, k):\n            if G.subgraph(subset).number_of_edges() == len(subset) * (len(subset) - 1) // 2:\n                if len(subset) > len(max_clique):\n                    max_clique = subset\n    return max_clique\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nclique_networkx_brute_force(G)",3
"def clique_randomized(n, edges):\n    import random\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    clique = set()\n    for node in nodes:\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_randomized(4, edges)",3
"def clique_greedy(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_greedy(4, edges)",3
"def kcoloring_largest_degree_first(n, edges, k):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    colors = [-1] * n\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_largest_degree_first(4, edges, 3)",4
"import random\n\ndef kcoloring_random_walk(n, edges, k):\n    colors = [-1] * n\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    for node in nodes:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_random_walk(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_largest_degree(G, k):\n    degree = {i: len(list(G.neighbors(i))) for i in G.nodes}\n    colors = {}\n    for node in sorted(G.nodes(), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_largest_degree(G, 3)",4
"def kcoloring_greedy_recursive(n, edges, k):\n    colors = [-1] * n\n    def assign_color(node):\n        if node == n:\n            return colors\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n            return assign_color(node + 1)\n        return None\n    return assign_color(0)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_greedy_recursive(4, edges, 3)",4
"import random\n\ndef kcoloring_simulated_annealing(n, edges, k, max_steps=1000):\n    colors = [random.choice(range(k)) for _ in range(n)]\n    temperature = 1000\n    def count_conflicts():\n        return sum(1 for u, v in edges if colors[u] == colors[v])\n    for _ in range(max_steps):\n        if count_conflicts() == 0:\n            return colors\n        node = random.choice(range(n))\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            new_color = random.choice(list(available_colors))\n            current_conflicts = count_conflicts()\n            colors[node] = new_color\n            if count_conflicts() >= current_conflicts and random.random() > (1.0 / temperature):\n                colors[node] = new_color  # Revert to previous\n        temperature *= 0.95\n    return None\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_simulated_annealing(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_simulated_annealing(G, k):\n    import random, math\n    colors = {node: random.choice(range(k)) for node in G.nodes()}\n    temperature = 1000\n    def count_conflicts():\n        return sum(1 for node in G.nodes() for neighbor in G.neighbors(node) if colors[node] == colors[neighbor])\n    for _ in range(1000):\n        if count_conflicts() == 0:\n            return colors\n        node = random.choice(list(G.nodes()))\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node)}\n        if available_colors:\n            new_color = random.choice(list(available_colors))\n            current_conflicts = count_conflicts()\n            colors[node] = new_color\n            if count_conflicts() >= current_conflicts and random.random() > (1.0 / temperature):\n                colors[node] = new_color  # Revert to previous\n        temperature *= 0.95\n    return None\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_simulated_annealing(G, 3)",4
"def kcoloring_backtracking_revised(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_backtracking_revised(4, edges, 3)",4
"import random\n\ndef kcoloring_random_restarts(n, edges, k, max_restarts=10):\n    def random_coloring():\n        colors = [-1] * n\n        nodes = list(range(n))\n        random.shuffle(nodes)\n        for node in nodes:\n            available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n            if available_colors:\n                colors[node] = random.choice(list(available_colors))\n        return colors\n    for _ in range(max_restarts):\n        colors = random_coloring()\n        if all(colors[node] != colors[neighbor] for u, v in edges for neighbor in [v]):\n            return colors\n    return None\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_random_restarts(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy_optimized(G, k):\n    degree = {i: len(list(G.neighbors(i))) for i in G.nodes()}\n    colors = {}\n    for node in sorted(G.nodes(), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n        else:\n            return None\n    return colors\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_greedy_optimized(G, 3)",4
"def kcoloring_custom_order(n, edges, k):\n    custom_order = [0, 3, 1, 2]  # Some arbitrary custom order\n    colors = [-1] * n\n    for node in custom_order:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_custom_order(4, edges, 3)",4
"def kcoloring_backtracking(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_backtracking(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy(G, k):\n    colors = {}\n    for node in G.nodes():\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_greedy(G, 3)\nprint(colors)",4
"def kcoloring_random(n, edges, k):\n    import random\n    colors = [-1] * n\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    for node in nodes:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v] if colors[neighbor] != -1}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_random(4, edges, 3)\nprint(colors)",4
"def kcoloring_sequential(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_sequential(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_backtracking(G, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for neighbor in G.neighbors(node))\n    def backtrack(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * len(G.nodes))\n\n# Input data\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_backtracking(G, 3)\nprint(colors)",4
"def kcoloring_greedy_degree_heuristic(n, edges, k):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    colors = [-1] * n\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_greedy_degree_heuristic(4, edges, 3)\nprint(colors)",4
"def kcoloring_dfs(n, edges, k):\n    def dfs(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v]):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * n)\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_dfs(4, edges, 3)\nprint(colors)",4
"import random\n\ndef kcoloring_simulated_annealing(n, edges, k, max_steps=1000):\n    colors = [random.choice(range(k)) for _ in range(n)]\n    temperature = 1000\n    def count_conflicts():\n        return sum(1 for u, v in edges if colors[u] == colors[v])\n    for _ in range(max_steps):\n        if count_conflicts() == 0:\n            return colors\n        node = random.choice(range(n))\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            new_color = random.choice(list(available_colors))\n            current_conflicts = count_conflicts()\n            colors[node] = new_color\n            if count_conflicts() >= current_conflicts and random.random() > (1.0 / temperature):\n                colors[node] = new_color  # Revert to previous\n        temperature *= 0.95\n    return None\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_simulated_annealing(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_dfs(G, k):\n    def dfs(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for neighbor in G.neighbors(node)):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * len(G.nodes))\n\n# Input data\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_dfs(G, 3)\nprint(colors)",4
"def kcoloring_custom_order(n, edges, k):\n    custom_order = [0, 3, 1, 2]  # Some arbitrary custom order\n    colors = [-1] * n\n    for node in custom_order:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_custom_order(4, edges, 3)\nprint(colors)",4
"def trial_division_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 100\nfactors = trial_division_factorization(n)\nprint(factors)",5
"def fermat_factorization(n):\n    if n % 2 == 0:\n        return [2, n // 2]\n    a = int(n**0.5) + 1\n    b2 = a*a - n\n    while int(b2**0.5)**2 != b2:\n        a += 1\n        b2 = a*a - n\n    b = int(b2**0.5)\n    return [a - b, a + b]\n\n# Input data\nn = 10403\nfactors = fermat_factorization(n)\nprint(factors)",5
"def pollard_rho_factorization(n):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    def f(x):\n        return (x*x + 1) % n\n    x, y, d = 2, 2, 1\n    while d == 1:\n        x = f(x)\n        y = f(f(y))\n        d = gcd(abs(x - y), n)\n    if d == n:\n        return None\n    return [d, n // d]\n\n# Input data\nn = 8059\nfactors = pollard_rho_factorization(n)\nprint(factors)",5
"def naive_factorization(n):\n    factors = []\n    for i in range(2, n + 1):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    return factors\n\n# Input data\nn = 987\nfactors = naive_factorization(n)\nprint(factors)",5
"def pollard_rho_optimized(n):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    def f(x):\n        return (x * x + 1) % n\n    x, y, d = 2, 2, 1\n    while d == 1:\n        x = f(x)\n        y = f(f(y))\n        d = gcd(abs(x - y), n)\n    if d == n:\n        return None\n    return [d, n // d]\n\n# Input data\nn = 99991\nfactors = pollard_rho_optimized(n)\nprint(factors)",5
"def optimized_trial_division(n):\n    factors = []\n    divisor = 2\n    while n % divisor == 0:\n        factors.append(divisor)\n        n //= divisor\n    divisor = 3\n    while n > 1 and divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 2\n    if n > 1:\n        factors.append(n)\n    return factors\n\n# Input data\nn = 1296\nfactors = optimized_trial_division(n)\nprint(factors)",5
"def fermat_modified_factorization(n):\n    if n % 2 == 0:\n        return [2, n // 2]\n    x = int(n**0.5) + 1\n    while True:\n        y2 = x*x - n\n        y = int(y2**0.5)\n        if y*y == y2:\n            break\n        x += 1\n    return [x - y, x + y]\n\n# Input data\nn = 11521\nfactors = fermat_modified_factorization(n)\nprint(factors)",5
"def simple_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 972\nfactors = simple_factorization(n)\nprint(factors)",5
"def pollard_brent_factorization(n):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    y, c, m = 2, 1, 100\n    g, r, q = 1, 1, 1\n    x, ys = 0, 0\n    while g == 1:\n        x = y\n        for i in range(r):\n            y = (y * y + c) % n\n        k = 0\n        while k < r and g == 1:\n            ys = y\n            for i in range(min(m, r - k)):\n                y = (y * y + c) % n\n                q = q * abs(x - y) % n\n            g = gcd(q, n)\n            k += m\n        r *= 2\n    if g == n:\n        while True:\n            ys = (ys * ys + c) % n\n            g = gcd(abs(x - ys), n)\n            if g > 1:\n                break\n    return [g, n // g]\n\n# Input data\nn = 7583\nfactors = pollard_brent_factorization(n)",5
"def max_cut_greedy(n, edges):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = max_cut_greedy(4, edges)\nprint(cut_value, A, B)",0
"def mis_greedy(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = mis_greedy(4, edges)\nprint(independent_set)",1
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_greedy(cost_matrix)\nprint(cost, route)",2
"def clique_greedy(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique = clique_greedy(4, edges)\nprint(clique)",3
"def kcoloring_greedy(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_greedy(4, edges, 3)\nprint(colors)",4
"def trial_division_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 120\nfactors = trial_division_factorization(n)\nprint(factors)",5
"def max_cut_brute_force(n, edges):\n    best_cut_value = 0\n    best_partition = None\n    for i in range(1 << n):\n        set_A = {j for j in range(n) if i & (1 << j)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in B and v in A))\n        if cut_value > best_cut_value:\n            best_cut_value = cut_value\n            best_partition = (set_A, set_B)\n    return best_cut_value, best_partition\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, partition = max_cut_brute_force(4, edges)\nprint(cut_value, partition)",0
"def mis_backtracking(n, edges):\n    def is_valid(independent_set, node):\n        return all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, current_set):\n        if node == n:\n            return current_set\n        with_node = backtrack(node + 1, current_set + [node]) if is_valid(current_set, node) else []\n        without_node = backtrack(node + 1, current_set)\n        return max(with_node, without_node, key=len)\n    return backtrack(0, [])\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = mis_backtracking(4, edges)\nprint(independent_set)",1
"def tsp_nearest_neighbor(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_nearest_neighbor(cost_matrix)\nprint(cost, route)",2
"def clique_backtracking(n, edges):\n    def is_clique(nodes):\n        return all((u, v) in edges or (v, u) in edges for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == n:\n            return current_clique\n        with_node = backtrack(node + 1, current_clique + [node]) if is_clique(current_clique + [node]) else []\n        without_node = backtrack(node + 1, current_clique)\n        return max(with_node, without_node, key=len)\n    return backtrack(0, [])\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique = clique_backtracking(4, edges)\nprint(clique)",3
"def kcoloring_backtracking(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_backtracking(4, edges, 3)\nprint(colors)",4
"def partition_greedy(n, edges):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = partition_greedy(4, edges)\nprint(cut_value, A, B)",0
"def vertex_selection_greedy(n, edges):\n    selection = set()\n    for node in range(n):\n        if all(neighbor not in selection for u, v in edges if u == node for neighbor in [v]):\n            selection.add(node)\n    return selection\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nselection = vertex_selection_greedy(4, edges)\nprint(selection)",1
"def route_planning(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = route_planning(cost_matrix)\nprint(cost, route)",2
"def group_selection(n, edges):\n    group = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in group):\n            group.add(node)\n    return group\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ngroup = group_selection(4, edges)\nprint(group)",3
"def color_assignment_greedy(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = color_assignment_greedy(4, edges, 3)\nprint(colors)",4
"def factorization_trial_division(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 120\nfactors = factorization_trial_division(n)\nprint(factors)",5
"def partition_exhaustive(n, edges):\n    best_cut_value = 0\n    best_partition = None\n    for i in range(1 << n):\n        set_A = {j for j in range(n) if i & (1 << j)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in B and v in A))\n        if cut_value > best_cut_value:\n            best_cut_value = cut_value\n            best_partition = (set_A, set_B)\n    return best_cut_value, best_partition\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, partition = partition_exhaustive(4, edges)\nprint(cut_value, partition)",0
"def vertex_selection_backtracking(n, edges):\n    def is_valid(selection, node):\n        return all(neighbor not in selection for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, current_set):\n        if node == n:\n            return current_set\n        with_node = backtrack(node + 1, current_set + [node]) if is_valid(current_set, node) else []\n        without_node = backtrack(node + 1, current_set)\n        return max(with_node, without_node, key=len)\n    return backtrack(0, [])\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nselection = vertex_selection_backtracking(4, edges)\nprint(selection)",1
"def nearest_city_route(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = nearest_city_route(cost_matrix)\nprint(cost, route)",2
"def group_backtracking(n, edges):\n    def is_group(nodes):\n        return all((u, v) in edges or (v, u) in edges for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_group):\n        if node == n:\n            return current_group\n        with_node = backtrack(node + 1, current_group + [node]) if is_group(current_group + [node]) else []\n        without_node = backtrack(node + 1, current_group)\n        return max(with_node, without_node, key=len)\n    return backtrack(0, [])\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ngroup = group_backtracking(4, edges)\nprint(group)",3
"def color_assignment_backtracking(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = color_assignment_backtracking(4, edges, 3)\nprint(colors)",4
"def factorization_recursive(n):\n    def recursive_division(n, divisor=2):\n        if n == 1:\n            return []\n        if n % divisor == 0:\n            return [divisor] + recursive_division(n // divisor, divisor)\n        return recursive_division(n, divisor + 1)\n    return recursive_division(n)\n\n# Input data\nn = 315\nfactors = factorization_recursive(n)\nprint(factors)",5
"def a(n):\n    def b(n, divisor=2):\n        if n == 1:\n            return []\n        if n % divisor == 0:\n            return [divisor] + b(n // divisor, divisor)\n        return b(n, divisor + 1)\n    return b(n)\n\n# Input data\nn = 315\nfactors = a(n)\nprint(factors)",5
"def c(n, edges):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = c(4, edges)\nprint(cut_value, A, B)",0
"def d(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = d(cost_matrix)\nprint(cost, route)",2
"def e(n, edges):\n    selection = set()\n    for node in range(n):\n        if all(neighbor not in selection for u, v in edges if u == node for neighbor in [v]):\n            selection.add(node)\n    return selection\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nselection = e(4, edges)\nprint(selection)",1
"def f(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = f(4, edges, 3)\nprint(colors)",4
"def a(n):\n    def b(n, divisor=2):\n        if n == 1:\n            return []\n        if n % divisor == 0:\n            return [divisor] + b(n // divisor, divisor)\n        return b(n, divisor + 1)\n    return b(n)\n\n# Input data\nn = 315\nfactors = a(n)\nprint(factors)",5
"def f1(n, edges):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = f1(4, edges)\nprint(cut_value, A, B)",0
"def x1(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = x1(cost_matrix)\nprint(cost, route)",2
"def y2(n, edges):\n    selection = set()\n    for node in range(n):\n        if all(neighbor not in selection for u, v in edges if u == node for neighbor in [v]):\n            selection.add(node)\n    return selection\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nselection = y2(4, edges)\nprint(selection)",1
"def z3(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = z3(4, edges, 3)\nprint(colors)",4
"def g3_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 120\nfactors = g3_factorization(n)\nprint(factors)",5
"def a(n):\n    def b(n, divisor=2):\n        if n == 1:\n            return []\n        if n % divisor == 0:\n            return [divisor] + b(n // divisor, divisor)\n        return b(n, divisor + 1)\n    return b(n)\n\n# Input data\nn = 315\nfactors = a(n)\nprint(factors)",5
"def f1(n, edges):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = f1(4, edges)\nprint(cut_value, A, B)",0
"def x1(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = x1(cost_matrix)\nprint(cost, route)",2
"def y2(n, edges):\n    selection = set()\n    for node in range(n):\n        if all(neighbor not in selection for u, v in edges if u == node for neighbor in [v]):\n            selection.add(node)\n    return selection\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nselection = y2(4, edges)\nprint(selection)",1
"def z3(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = z3(4, edges, 3)\nprint(colors)",4
"def g3_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 120\nfactors = g3_factorization(n)\nprint(factors)",5
"def w4(edges, n):\n    best_cut, best_partition = 0, None\n    for mask in range(1 << n):\n        set_A = {i for i in range(n) if mask & (1 << i)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n        if cut_value > best_cut:\n            best_cut, best_partition = cut_value, (set_A, set_B)\n    return best_cut, best_partition\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nbest_cut, best_partition = w4(edges, 4)\nprint(best_cut, best_partition)",0
"def q5(n, edges):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = q5(4, edges)\nprint(cut_value, A, B)",0
"def a2(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = a2(cost_matrix)\nprint(cost, route)",2
"def p2(n, edges):\n    group = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in group):\n            group.add(node)\n    return group\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ngroup = p2(4, edges)\nprint(group)",3
"def r4(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = r4(4, edges, 3)\nprint(colors)",4
"def k5_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 72\nfactors = k5_factorization(n)\nprint(factors)",5
"def h7(edges, n):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, set_A, set_B = h7(edges, 4)\nprint(cut_value, set_A, set_B)",0
"def g9(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = g9(4, edges)\nprint(independent_set)",1
"def y8(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 5, 15, 25], [5, 0, 35, 25], [15, 35, 0, 30], [25, 25, 30, 0]]\ncost, route = y8(cost_matrix)\nprint(cost, route)",2
"def v3(n, edges):\n    group = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in group):\n            group.add(node)\n    return group\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ngroup = v3(4, edges)\nprint(group)",3
"def n6_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 144\nfactors = n6_factorization(n)\nprint(factors)",5
"def s3(edges, n):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    return sum(1 for u, v in edges if (u in A and v in B)), A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = s3(edges, 4)\nprint(cut_value, A, B)",0
"def u4_selection(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nselection = u4_selection(4, edges)\nprint(selection)",1
"def f_add(x, y):\n    return x + y\n\n# Input data\nx, y = 5, 3\nresult = f_add(x, y)\nprint(result)",6
"def f_subtract(a, b):\n    return a - b\n\n# Input data\na, b = 10, 7\nresult = f_subtract(a, b)\nprint(result)",8
"def f_multiply(m, n):\n    return m * n\n\n# Input data\nm, n = 4, 9\nresult = f_multiply(m, n)\nprint(result)",7
"def a(x, y):\n    return x + y\n\n# Input data\nx, y = 15, 27\nresult = a(x, y)\nprint(result)",6
"def b(a, b):\n    return a - b\n\n# Input data\na, b = 12, 5\nresult = b(a, b)\nprint(result)",8
"def c(m, n):\n    return m * n\n\n# Input data\nm, n = 3, 6\nresult = c(m, n)\nprint(result)",7
"def g(a, b):\n    return a + b\n\n# Input data\na, b = 8, 2\nresult = g(a, b)\nprint(result)",6
"def h(a, b):\n    return a - b\n\n# Input data\na, b = 20, 10\nresult = h(a, b)\nprint(result)",8
"def i(a, b):\n    return a * b\n\n# Input data\na, b = 7, 8\nresult = i(a, b)\nprint(result)",7
"def x1_add(p, q):\n    return p + q\n\n# Input data\np, q = 33, 22\nresult = x1_add(p, q)\nprint(result)",6
"def y2_sub(m, n):\n    return m - n\n\n# Input data\nm, n = 14, 7\nresult = y2_sub(m, n)\nprint(result)",8
"def z3_mult(a, b):\n    return a * b\n\n# Input data\na, b = 9, 9\nresult = z3_mult(a, b)\nprint(result)",7
"def add(x, y):\n    return x + y\n\n# Input data\nx, y = 19, 21\nresult = add(x, y)\nprint(result)",6
"def subtract(a, b):\n    return a - b\n\n# Input data\na, b = 45, 23\nresult = subtract(a, b)\nprint(result)",8
"def multiply(m, n):\n    return m * n\n\n# Input data\nm, n = 8, 5\nresult = multiply(m, n)\nprint(result)",7
"def g1_add(a, b):\n    return a + b\n\n# Input data\na, b = 100, 200\nresult = g1_add(a, b)\nprint(result)",6
"def h1_subtract(x, y):\n    return x - y\n\n# Input data\nx, y = 56, 29\nresult = h1_subtract(x, y)\nprint(result)",8
"def j1_multiply(m, n):\n    return m * n\n\n# Input data\nm, n = 11, 6\nresult = j1_multiply(m, n)\nprint(result)",7
"def k1_add(x, y):\n    return x + y\n\n# Input data\nx, y = 14, 26\nresult = k1_add(x, y)\nprint(result)",6
"def l1_subtract(a, b):\n    return a - b\n\n# Input data\na, b = 33, 18\nresult = l1_subtract(a, b)\nprint(result)",8
"def m1_multiply(a, b):\n    return a * b\n\n# Input data\na, b = 12, 8\nresult = m1_multiply(a, b)\nprint(result)",7
"def n1_add(a, b):\n    return a + b\n\n# Input data\na, b = 77, 88\nresult = n1_add(a, b)\nprint(result)",6
"def o1_subtract(x, y):\n    return x - y\n\n# Input data\nx, y = 90, 45\nresult = o1_subtract(x, y)\nprint(result)",8
"def p1_multiply(x, y):\n    return x * y\n\n# Input data\nx, y = 13, 7\nresult = p1_multiply(x, y)\nprint(result)",7
"def r1_add(m, n):\n    return m + n\n\n# Input data\nm, n = 101, 303\nresult = r1_add(m, n)\nprint(result)",6
"def s1_subtract(a, b):\n    return a - b\n\n# Input data\na, b = 87, 50\nresult = s1_subtract(a, b)\nprint(result)",8
"def t1_multiply(m, n):\n    return m * n\n\n# Input data\nm, n = 25, 5\nresult = t1_multiply(m, n)\nprint(result)",7
"def u1_add(a, b):\n    return a + b\n\n# Input data\na, b = 300, 150\nresult = u1_add(a, b)\nprint(result)",6
"def v1_subtract(x, y):\n    return x - y\n\n# Input data\nx, y = 78, 24\nresult = v1_subtract(x, y)\nprint(result)",8
"def w1_multiply(a, b):\n    return a * b\n\n# Input data\na, b = 15, 9\nresult = w1_multiply(a, b)\nprint(result)",7
"def x1_add(p, q):\n    return p + q\n\n# Input data\np, q = 125, 375\nresult = x1_add(p, q)\nprint(result)",6
"def y1_subtract(m, n):\n    return m - n\n\n# Input data\nm, n = 1000, 555\nresult = y1_subtract(m, n)\nprint(result)",8
"def z1_multiply(a, b):\n    return a * b\n\n# Input data\na, b = 45, 23\nresult = z1_multiply(a, b)\nprint(result)",7
"def a2_add(a, b):\n    return a + b\n\n# Input data\na, b = 78, 92\nresult = a2_add(a, b)\nprint(result)",6
"def b2_subtract(x, y):\n    return x - y\n\n# Input data\nx, y = 300, 120\nresult = b2_subtract(x, y)\nprint(result)",8
"def f_add(a, b):\n    return a + b\n\n# Input data\na, b = 10, 20\nresult = f_add(a, b)\nprint(result)",6
"def g_add(x, y):\n    return x + y\n\n# Input data\nx, y = 7, 8\nresult = g_add(x, y)\nprint(result)",6
"def sum_two(p, q):\n    return p + q\n\n# Input data\np, q = 45, 55\nresult = sum_two(p, q)\nprint(result)",6
"def add_simple(x, y):\n    return x + y\n\n# Input data\nx, y = 3, 4\nresult = add_simple(x, y)\nprint(result)",6
"def simple_sub(a, b):\n    return a - b\n\n# Input data\na, b = 15, 5\nresult = simple_sub(a, b)\nprint(result)",8
"def sub_two(x, y):\n    return x - y\n\n# Input data\nx, y = 100, 50\nresult = sub_two(x, y)\nprint(result)",8
"def diff_calc(a, b):\n    return a - b\n\n# Input data\na, b = 42, 18\nresult = diff_calc(a, b)\nprint(result)",8
"def subtract_vals(x, y):\n    return x - y\n\n# Input data\nx, y = 33, 11\nresult = subtract_vals(x, y)\nprint(result)",8
"def multiply_vals(x, y):\n    return x * y\n\n# Input data\nx, y = 9, 8\nresult = multiply_vals(x, y)\nprint(result)",7
"def f_multiply(a, b):\n    return a * b\n\n# Input data\na, b = 6, 7\nresult = f_multiply(a, b)\nprint(result)",7
"def g_multiply(p, q):\n    return p * q\n\n# Input data\np, q = 4, 12\nresult = g_multiply(p, q)\nprint(result)",7
"def simple_mult(a, b):\n    return a * b\n\n# Input data\na, b = 14, 6\nresult = simple_mult(a, b)\nprint(result)",7
"def max_partition(edges, n):\n    A, B = set(), set()\n    for node in range(n):\n        if len(A) < len(B):\n            A.add(node)\n        else:\n            B.add(node)\n    return sum(1 for u, v in edges if (u in A and v in B)), A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncut_value, A, B = max_partition(edges, 4)\nprint(cut_value, A, B)",0
"def min_cut_strategy(edges, n):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncut_value, set_A, set_B = min_cut_strategy(edges, 4)\nprint(cut_value, set_A, set_B)",0
"def independent_nodes(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nindependent_set = independent_nodes(4, edges)\nprint(independent_set)",1
"def max_independent(n, edges):\n    group = set()\n    for node in range(n):\n        if all(neighbor not in group for u, v in edges if u == node for neighbor in [v]):\n            group.add(node)\n    return group\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = max_independent(4, edges)\nprint(result)",1
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15], [10, 0, 35], [15, 35, 0]]\ncost, route = tsp_greedy(cost_matrix)\nprint(cost, route)",2
"def nearest_neighbor(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 8, 20], [8, 0, 30], [20, 30, 0]]\ncost, route = nearest_neighbor(cost_matrix)\nprint(cost, route)",2
"def clique_search(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = clique_search(4, edges)\nprint(result)",3
"def find_clique(n, edges):\n    max_clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in max_clique):\n            max_clique.add(node)\n    return max_clique\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = find_clique(4, edges)\nprint(result)",3
"def coloring_greedy(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = coloring_greedy(4, edges, 3)\nprint(colors)",4
"def kcolor_assignment(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = kcolor_assignment(4, edges, 3)\nprint(colors)",4
"def x_sum(x, y):\n    return x + y\n\n# Input data\nx, y = 17, 22\nresult = x_sum(x, y)\nprint(result)",6
"def compute_addition(a, b):\n    return a + b\n\n# Input data\na, b = 31, 19\nresult = compute_addition(a, b)\nprint(result)",6
"def add_two_values(p, q):\n    return p + q\n\n# Input data\np, q = 58, 42\nresult = add_two_values(p, q)\nprint(result)",6
"def basic_add(x, y):\n    return x + y\n\n# Input data\nx, y = 9, 5\nresult = basic_add(x, y)\nprint(result)",6
"def subtract_simple(a, b):\n    return a - b\n\n# Input data\na, b = 88, 20\nresult = subtract_simple(a, b)\nprint(result)",8
"def compute_difference(x, y):\n    return x - y\n\n# Input data\nx, y = 50, 25\nresult = compute_difference(x, y)\nprint(result)",8
"def subtract_two_values(a, b):\n    return a - b\n\n# Input data\na, b = 91, 33\nresult = subtract_two_values(a, b)\nprint(result)",8
"def find_difference(x, y):\n    return x - y\n\n# Input data\nx, y = 62, 21\nresult = find_difference(x, y)\nprint(result)",8
"def calc_multiplication(x, y):\n    return x * y\n\n# Input data\nx, y = 7, 8\nresult = calc_multiplication(x, y)\nprint(result)",7
"def basic_mult(a, b):\n    return a * b\n\n# Input data\na, b = 13, 14\nresult = basic_mult(a, b)\nprint(result)",7
"def compute_product(p, q):\n    return p * q\n\n# Input data\np, q = 9, 9\nresult = compute_product(p, q)\nprint(result)",7
"def multiply_simple(a, b):\n    return a * b\n\n# Input data\na, b = 19, 3\nresult = multiply_simple(a, b)\nprint(result)",7
"def cut_partition(edges, n):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncut_value, set_A, set_B = cut_partition(edges, 4)\nprint(cut_value, set_A, set_B)",0
"def simple_cut_strategy(edges, n):\n    A, B = set(), set()\n    for node in range(n):\n        if len(A) < len(B):\n            A.add(node)\n        else:\n            B.add(node)\n    return sum(1 for u, v in edges if (u in A and v in B)), A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncut_value, A, B = simple_cut_strategy(edges, 4)\nprint(cut_value, A, B)",0
"def compute_independent(n, edges):\n    selection = set()\n    for node in range(n):\n        if all(neighbor not in selection for u, v in edges if u == node for neighbor in [v]):\n            selection.add(node)\n    return selection\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nselection = compute_independent(4, edges)\nprint(selection)",1
"def independent_calc(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = independent_calc(4, edges)\nprint(result)",1
"def tsp_heuristic(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 5, 20], [5, 0, 30], [20, 30, 0]]\ncost, route = tsp_heuristic(cost_matrix)\nprint(cost, route)",2
"def greedy_tsp(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 25], [10, 0, 35], [25, 35, 0]]\ncost, route = greedy_tsp(cost_matrix)\nprint(cost, route)",2
"def clique_max_search(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = clique_max_search(4, edges)\nprint(result)",3
"def max_clique_calc(n, edges):\n    group = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in group):\n            group.add(node)\n    return group\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = max_clique_calc(4, edges)\nprint(result)",3
"def greedy_kcoloring(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = greedy_kcoloring(4, edges, 3)\nprint(colors)",4
"def kcolor_strategy(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = kcolor_strategy(4, edges, 3)\nprint(colors)",4
"def sum_func(x1, x2):\n    return x1 + x2\n\n# Input data\nx1, x2 = 10, 15\nresult = sum_func(x1, x2)\nprint(result)",6
"def plus_op(a, b):\n    return a + b\n\n# Input data\na, b = 23, 32\nresult = plus_op(a, b)\nprint(result)",6
"def total(x, y):\n    return x + y\n\n# Input data\nx, y = 45, 5\nresult = total(x, y)\nprint(result)",6
"def simple_plus(v1, v2):\n    return v1 + v2\n\n# Input data\nv1, v2 = 100, 1\nresult = simple_plus(v1, v2)\nprint(result)",6
"def diff_func(p, q):\n    return p - q\n\n# Input data\np, q = 70, 50\nresult = diff_func(p, q)\nprint(result)",8
"def minus_op(n1, n2):\n    return n1 - n2\n\n# Input data\nn1, n2 = 99, 12\nresult = minus_op(n1, n2)\nprint(result)",8
"def subtract_it(val1, val2):\n    return val1 - val2\n\n# Input data\nval1, val2 = 300, 100\nresult = subtract_it(val1, val2)\nprint(result)",8
"def take_away(x, y):\n    return x - y\n\n# Input data\nx, y = 20, 5\nresult = take_away(x, y)\nprint(result)",8
"def multiply_func(i, j):\n    return i * j\n\n# Input data\ni, j = 6, 12\nresult = multiply_func(i, j)\nprint(result)",7
"def mult_two_numbers(val1, val2):\n    return val1 * val2\n\n# Input data\nval1, val2 = 13, 4\nresult = mult_two_numbers(val1, val2)\nprint(result)",7
"def calc_product(n1, n2):\n    return n1 * n2\n\n# Input data\nn1, n2 = 10, 9\nresult = calc_product(n1, n2)\nprint(result)",7
"def product_of(x, y):\n    return x * y\n\n# Input data\nx, y = 100, 2\nresult = product_of(x, y)\nprint(result)",7
"def max_cut_solution(edges, num_nodes):\n    A, B = set(), set()\n    for node in range(num_nodes):\n        if len(A) < len(B):\n            A.add(node)\n        else:\n            B.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncut_value, A, B = max_cut_solution(edges, 4)\nprint(cut_value, A, B)",0
"def independent_set_finder(nodes, edges):\n    iset = set()\n    for node in nodes:\n        if all(neighbor not in iset for u, v in edges if u == node for neighbor in [v]):\n            iset.add(node)\n    return iset\n\n# Input data\nnodes = [0, 1, 2, 3]\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = independent_set_finder(nodes, edges)\nprint(result)",1
"def compute_clique(nodes, edges):\n    clique = set()\n    for node in nodes:\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\n# Input data\nnodes = [0, 1, 2, 3]\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = compute_clique(nodes, edges)\nprint(result)",3
"def tsp_solver(dist_matrix):\n    n = len(dist_matrix)\n    visited = [0]\n    total_cost = 0\n    current = 0\n    while len(visited) < n:\n        next_city = min([city for city in range(n) if city not in visited], key=lambda city: dist_matrix[current][city])\n        total_cost += dist_matrix[current][next_city]\n        visited.append(next_city)\n        current = next_city\n    total_cost += dist_matrix[visited[-1]][0]\n    return total_cost, visited\n\n# Input data\ndist_matrix = [[0, 15, 20], [15, 0, 35], [20, 35, 0]]\ncost, route = tsp_solver(dist_matrix)\nprint(cost, route)",2
"def greedy_coloring(nodes, edges, k):\n    color_map = [-1] * len(nodes)\n    for node in nodes:\n        neighbor_colors = {color_map[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        available_colors = set(range(k)) - neighbor_colors\n        color_map[node] = min(available_colors) if available_colors else -1\n    return color_map\n\n# Input data\nnodes = [0, 1, 2, 3]\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = greedy_coloring(nodes, edges, 3)\nprint(colors)",4
"def compute_coloring(n, edges, k):\n    color_assignment = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {color_assignment[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            color_assignment[node] = min(available_colors)\n    return color_assignment\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = compute_coloring(4, edges, 3)\nprint(colors)",4
"def independent_set_finder_v2(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nselection = independent_set_finder_v2(4, edges)\nprint(selection)",1
"def partition_strategy(edges, nodes):\n    group_A, group_B = set(), set()\n    for node in nodes:\n        if len(group_A) < len(group_B):\n            group_A.add(node)\n        else:\n            group_B.add(node)\n    return group_A, group_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ngroup_A, group_B = partition_strategy(edges, [0, 1, 2, 3])\nprint(group_A, group_B)",0
"def color_assignment_solver(n, edges, colors_available):\n    colors = [-1] * n\n    for node in range(n):\n        used_colors = {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        available_colors = set(colors_available) - used_colors\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = color_assignment_solver(4, edges, [0, 1, 2])\nprint(colors)",4
"def f(a, b):\n    return a + b\n\n# Input data\na, b = 25, 17\nresult = f(a, b)\nprint(result)",6
"def a(x, y):\n    return x + y\n\n# Input data\nx, y = 10, 3\nresult = a(x, y)\nprint(result)",6
"def do_something(a, b):\n    return a + b\n\n# Input data\na, b = 12, 7\nresult = do_something(a, b)\nprint(result)",6
"def add_values(p, q):\n    return p + q\n\n# Input data\np, q = 8, 8\nresult = add_values(p, q)\nprint(result)",6
"def f(a, b):\n    return a - b\n\n# Input data\na, b = 10, 4\nresult = f(a, b)\nprint(result)",8
"def a(x, y):\n    return x - y\n\n# Input data\nx, y = 25, 10\nresult = a(x, y)\nprint(result)",8
"def do_something(a, b):\n    return a - b\n\n# Input data\na, b = 100, 50\nresult = do_something(a, b)\nprint(result)",8
"def subtract_vals(x, y):\n    return x - y\n\n# Input data\nx, y = 17, 5\nresult = subtract_vals(x, y)\nprint(result)",8
"def f(a, b):\n    return a * b\n\n# Input data\na, b = 6, 7\nresult = f(a, b)\nprint(result)",7
"def a(x, y):\n    return x * y\n\n# Input data\nx, y = 9, 9\nresult = a(x, y)\nprint(result)",7
"def do_something(p, q):\n    return p * q\n\n# Input data\np, q = 8, 4\nresult = do_something(p, q)\nprint(result)",7
"def multiply_values(a, b):\n    return a * b\n\n# Input data\na, b = 10, 11\nresult = multiply_values(a, b)\nprint(result)",7
"def f(edges, n):\n    set_A, set_B = set(), set()\n    for node in range(n):\n        if len(set_A) < len(set_B):\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B))\n    return cut_value, set_A, set_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncut_value, set_A, set_B = f(edges, 4)\nprint(cut_value, set_A, set_B)",0
"def a(nodes, edges):\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nnodes = [0, 1, 2, 3]\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = a(nodes, edges)\nprint(result)",1
"def do_something(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = do_something(4, edges)\nprint(result)",1
"def f(dist_matrix):\n    n = len(dist_matrix)\n    visited = [0]\n    total_cost = 0\n    current = 0\n    while len(visited) < n:\n        next_city = min([city for city in range(n) if city not in visited], key=lambda city: dist_matrix[current][city])\n        total_cost += dist_matrix[current][next_city]\n        visited.append(next_city)\n        current = next_city\n    total_cost += dist_matrix[visited[-1]][0]\n    return total_cost, visited\n\n# Input data\ndist_matrix = [[0, 12, 24], [12, 0, 36], [24, 36, 0]]\ncost, route = f(dist_matrix)\nprint(cost, route)",2
"def a(cost_matrix):\n    n = len(cost_matrix)\n    visited = [0]\n    total_cost = 0\n    current = 0\n    while len(visited) < n:\n        next_city = min([city for city in range(n) if city not in visited], key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        visited.append(next_city)\n        current = next_city\n    total_cost += cost_matrix[visited[-1]][0]\n    return total_cost, visited\n\n# Input data\ncost_matrix = [[0, 11, 30], [11, 0, 35], [30, 35, 0]]\ncost, route = a(cost_matrix)\nprint(cost, route)",2
"def do_something(dist_matrix):\n    n = len(dist_matrix)\n    visited = [0]\n    total_cost = 0\n    current = 0\n    while len(visited) < n:\n        next_city = min([city for city in range(n) if city not in visited], key=lambda city: dist_matrix[current][city])\n        total_cost += dist_matrix[current][next_city]\n        visited.append(next_city)\n        current = next_city\n    total_cost += dist_matrix[visited[-1]][0]\n    return total_cost, visited\n\n# Input data\ndist_matrix = [[0, 18, 22], [18, 0, 27], [22, 27, 0]]\ncost, route = do_something(dist_matrix)\nprint(cost, route)",2
"def f(n, edges):\n    group_A, group_B = set(), set()\n    for node in range(n):\n        if len(group_A) < len(group_B):\n            group_A.add(node)\n        else:\n            group_B.add(node)\n    return group_A, group_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ngroup_A, group_B = f(4, edges)\nprint(group_A, group_B)",0
"def a(n, edges):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return set_A, set_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nset_A, set_B = a(4, edges)\nprint(set_A, set_B)",0
"def do_something(n, edges):\n    group_A, group_B = set(), set()\n    for node in range(n):\n        if len(group_A) < len(group_B):\n            group_A.add(node)\n        else:\n            group_B.add(node)\n    return group_A, group_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ngroup_A, group_B = do_something(4, edges)\nprint(group_A, group_B)",0
