code_snippet,labels
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nresult = maximum_cut(G)\nprint(result)",0
"import networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (1, 3), (2, 4), (3, 4), (4, 5)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (0, 2), (0, 3), (1, 3), (2, 3), (1, 4)])\nresult = maximum_cut(G)\nprint(result)",0
"import networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nresult = maximum_cut(G)\nprint(result)",0
"import networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (0, 2), (2, 3), (3, 4)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (0, 2), (2, 4)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport networkx as nx\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 4), (1, 4), (2, 5)])\nresult = maximum_cut(G)\nprint(result)",0
"# Python code\nimport itertools\nimport networkx as nx\n\ndef maxcut_bruteforce(G):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for i in range(1, len(nodes)):\n        for cut in itertools.combinations(nodes, i):\n            partition_A = set(cut)\n            partition_B = set(nodes) - partition_A\n            cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n            if cut_value > max_cut_value:\n                max_cut_value = cut_value\n                best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4), (4, 5)])\nmax_cut_value, best_partition = maxcut_bruteforce(G)\nprint(f""Maximum cut value: {max_cut_value}"")\nprint(f""Best partition: {best_partition}"")",0
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_maxcut(G, iterations=1000):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n        if cut_value > max_cut_value:\n            max_cut_value = cut_value\n            best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nmax_cut_value, best_partition = randomized_maxcut(G)\nprint(f""Maximum cut value: {max_cut_value}"")\nprint(f""Best partition: {best_partition}"")",0
"import itertools\nimport networkx as nx\n\ndef maxcut_bruteforce(G):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for i in range(1, len(nodes)):\n        for cut in itertools.combinations(nodes, i):\n            partition_A = set(cut)\n            partition_B = set(nodes) - partition_A\n            cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n            if cut_value > max_cut_value:\n                max_cut_value = cut_value\n                best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 4), (4, 5)])\nmax_cut_value, best_partition = maxcut_bruteforce(G)\nprint(f""Maximum cut value: {max_cut_value}"")\nprint(f""Best partition: {best_partition}"")",0
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_maxcut(G, iterations=1000):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n        if cut_value > max_cut_value:\n            max_cut_value = cut_value\n            best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nmax_cut_value, best_partition = randomized_maxcut(G)\nprint(f""Maximum cut value: {max_cut_value}"")\nprint(f""Best partition: {best_partition}"")",0
"import networkx as nx\nimport random\n\ndef randomized_maximal_independent_set(G):\n    independent_set = set()\n    nodes = list(G.nodes())\n    random.shuffle(nodes)\n    while nodes:\n        node = nodes.pop(0)\n        independent_set.add(node)\n        for neighbor in G.neighbors(node):\n            if neighbor in nodes:\n                nodes.remove(neighbor)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nindependent_set = randomized_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef iterative_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = set(G.nodes())\n    while remaining_nodes:\n        node = remaining_nodes.pop()\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes -= neighbors\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = iterative_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"import networkx as nx\n\ndef heuristic_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x), reverse=True)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nindependent_set = heuristic_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef backtrack_maximal_independent_set(G, remaining_nodes=None, independent_set=None):\n    if independent_set is None:\n        independent_set = set()\n    if remaining_nodes is None:\n        remaining_nodes = set(G.nodes())\n    if not remaining_nodes:\n        return independent_set\n    node = remaining_nodes.pop()\n    new_set = independent_set.copy()\n    new_set.add(node)\n    neighbors = set(G.neighbors(node))\n    return backtrack_maximal_independent_set(G, remaining_nodes - neighbors, new_set)\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = backtrack_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef dfs_maximal_independent_set(G):\n    def dfs(node, visited, independent_set):\n        visited.add(node)\n        independent_set.add(node)\n        for neighbor in G.neighbors(node):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                for neighbor_of_neighbor in G.neighbors(neighbor):\n                    if neighbor_of_neighbor not in visited:\n                        dfs(neighbor_of_neighbor, visited, independent_set)\n    visited = set()\n    independent_set = set()\n    for node in G.nodes():\n        if node not in visited:\n            dfs(node, visited, independent_set)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = dfs_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"import networkx as nx\n\ndef degree_based_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x))\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)])\nindependent_set = degree_based_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"import networkx as nx\n\ndef lexicographical_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes())\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = lexicographical_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\nfrom collections import deque\n\ndef bfs_maximal_independent_set(G):\n    independent_set = set()\n    visited = set()\n    queue = deque(G.nodes())\n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            independent_set.add(node)\n            visited.add(node)\n            for neighbor in G.neighbors(node):\n                visited.add(neighbor)\n                for n in G.neighbors(neighbor):\n                    if n not in visited and n not in queue:\n                        queue.append(n)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = bfs_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef degree_first_mis(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x), reverse=True)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = degree_first_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_greedy_mis(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x))\n    random.shuffle(remaining_nodes)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = randomized_greedy_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_degree_maximal_independent_set(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x))\n    random.shuffle(remaining_nodes)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = randomized_degree_maximal_independent_set(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"import networkx as nx\n\ndef greedy_mis_variation(graph):\n    independent_set = set()\n    remaining_nodes = sorted(graph.nodes(), key=lambda x: graph.degree(x), reverse=True)\n    while remaining_nodes:\n        n = remaining_nodes.pop(0)\n        independent_set.add(n)\n        neighbors = set(graph.neighbors(n))\n        remaining_nodes = [node for node in remaining_nodes if node not in neighbors]\n    return independent_set\n\ngraph = nx.Graph()\ngraph.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 5), (5, 0)])\nmis_set = greedy_mis_variation(graph)\nprint(f""Maximal Independent Set: {mis_set}"")",1
"# Python code\nimport itertools\nimport networkx as nx\n\ndef brute_force_maxcut(G):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for i in range(1, len(nodes)):\n        for cut in itertools.combinations(nodes, i):\n            partition_A = set(cut)\n            partition_B = set(nodes) - partition_A\n            cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n            if cut_value > max_cut_value:\n                max_cut_value = cut_value\n                best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value, partition = brute_force_maxcut(G)\nprint(f""Maximum Cut Value: {cut_value}"")\nprint(f""Best Partition: {partition}"")",0
"import networkx as nx\n\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nresult = maximum_cut(G)\nprint(result)",1
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_maxcut(G, iterations=1000):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n        if cut_value > max_cut_value:\n            max_cut_value = cut_value\n            best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nmax_cut_value, best_partition = randomized_maxcut(G)\nprint(f\""Maximum cut value: {max_cut_value}\"")\nprint(f\""Best partition: {best_partition}\"")",1
"""import networkx as nx\n\ndef maximum_cut(G):\n    # Calculate maximum cut value using a greedy algorithm\n    partition_A = set()\n    partition_B = set(G.nodes())\n    for node in G.nodes():\n        # Assign the node to partition based on neighbors\n        if sum(1 for neighbor in G.neighbors(node) if neighbor in partition_A) > sum(1 for neighbor in G.neighbors(node) if neighbor in partition_B):\n            partition_B.add(node)\n        else:\n            partition_A.add(node)\n    # Calculate the maximum cut\n    cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value = maximum_cut(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""import networkx as nx\n\ndef maximum_cut_randomized(G):\n    # Use a randomized approach to solve Maximum Cut\n    import random\n    partition_A = set(random.sample(G.nodes(), len(G.nodes()) // 2))\n    partition_B = set(G.nodes()) - partition_A\n    cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 0)])\ncut_value = maximum_cut_randomized(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef independent_set(G):\n    # Find the independent set of the graph\n    independent_set = set()\n    for node in G.nodes():\n        # Add the node to independent set if none of its neighbors are in the set\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = independent_set(G)\nprint(f\""Independent Set: {result}\"")""",0
"""import networkx as nx\n\ndef independent_set_greedy(G):\n    # Greedy approach to find maximal independent set\n    independent_set = set()\n    for node in sorted(G.nodes(), key=lambda n: G.degree(n)):\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 4), (4, 3)])\nresult = independent_set_greedy(G)\nprint(f\""Maximal Independent Set: {result}\"")""",1
"# Python code\nimport networkx as nx\n\ndef independent_set(G):\n    independent_set = set()\n    for node in G.nodes():\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = independent_set(G)\nprint(f\""Independent Set: {result}\"")",0
"""# Python code\nimport networkx as nx\n\ndef max_cut_greedy_algorithm(graph):\n    # Solve maximum cut using a greedy algorithm\n    set_A = set()\n    set_B = set(graph.nodes())\n    for vertex in graph.nodes():\n        # Assign vertex to partition based on neighbors\n        if sum(1 for neighbor in graph.neighbors(vertex) if neighbor in set_A) > sum(1 for neighbor in graph.neighbors(vertex) if neighbor in set_B):\n            set_B.add(vertex)\n        else:\n            set_A.add(vertex)\n    # Calculate the cut value\n    cut_val = sum(1 for u, v in graph.edges() if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_val\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 0)])\ncut_value = max_cut_greedy_algorithm(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""import networkx as nx\nimport random\n\ndef randomized_maximum_cut_solution(G):\n    # Randomized method to find maximum cut\n    part_A = set(random.sample(G.nodes(), len(G.nodes()) // 2))\n    part_B = set(G.nodes()) - part_A\n    cut_value = sum(1 for u, v in G.edges() if (u in part_A and v in part_B) or (u in part_B and v in part_A))\n    return cut_value\n\n# Create graph\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value = randomized_maximum_cut_solution(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef find_independent_set(G):\n    # Heuristic approach to find maximal independent set\n    ind_set = set()\n    for v in sorted(G.nodes(), key=lambda x: G.degree(x)):\n        # Add node to independent set if none of its neighbors are in the set\n        if all(neighbor not in ind_set for neighbor in G.neighbors(v)):\n            ind_set.add(v)\n    return ind_set\n\n# Example graph\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 4), (4, 3)])\nindependent_set = find_independent_set(G)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""# Python code\nimport networkx as nx\n\ndef independent_set_randomized(graph):\n    # Randomized approach to find maximal independent set\n    import random\n    i_set = set()\n    remaining_nodes = list(graph.nodes())\n    random.shuffle(remaining_nodes)\n    for node in remaining_nodes:\n        if all(neighbor not in i_set for neighbor in graph.neighbors(node)):\n            i_set.add(node)\n    return i_set\n\n# Create graph\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = independent_set_randomized(G)\nprint(f\""Independent Set: {result}\"")""",1
"import networkx as nx\nfrom itertools import permutations\n\ndef tsp_brute_force(graph):\n    # Brute-force solution for TSP\n    nodes = list(graph.nodes())\n    min_cost = float('inf')\n    best_route = None\n    for route in permutations(nodes):\n        cost = sum(graph[route[i]][route[i+1]]['weight'] for i in range(len(route) - 1)) + graph[route[-1]][route[0]]['weight']\n        if cost < min_cost:\n            min_cost = cost\n            best_route = route\n    return min_cost, best_route\n\n# Create a graph with weighted edges\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\nmin_cost, route = tsp_brute_force(G)",2
"# Python code\nimport networkx as nx\nfrom itertools import permutations\n\ndef traveling_salesman_dp(graph):\n    # Solve TSP using Dynamic Programming\n    nodes = list(graph.nodes())\n    n = len(nodes)\n    dp = [[None] * (1 << n) for _ in range(n)]\n    def tsp(pos, visited):\n        if visited == (1 << n) - 1:\n            return graph[pos][0]['weight'] if 0 in graph[pos] else float('inf')\n        if dp[pos][visited] is not None:\n            return dp[pos][visited]\n        ans = float('inf')\n        for city in range(n):\n            if visited & (1 << city) == 0 and city in graph[pos]:\n                ans = min(ans, graph[pos][city]['weight'] + tsp(city, visited | (1 << city)))\n        dp[pos][visited] = ans\n        return ans\n    return tsp(0, 1)\n\n# Example graph with weighted edges\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 12), (1, 2, 10), (2, 3, 8), (3, 0, 15)])\nmin_cost = traveling_salesman_dp(G)",2
"""import networkx as nx\nimport random\n\ndef tsp_randomized_approximation(graph):\n    # Randomized approximation algorithm for TSP\n    nodes = list(graph.nodes())\n    random.shuffle(nodes)\n    total_cost = 0\n    route = [nodes[0]]\n    for i in range(1, len(nodes)):\n        total_cost += graph[nodes[i - 1]][nodes[i]]['weight']\n        route.append(nodes[i])\n    total_cost += graph[route[-1]][route[0]]['weight']\n    return total_cost, route\n\n# Example graph with weighted edges\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 0, 40)])\ncost, route = tsp_randomized_approximation(G)""",2
"""def maximum_cut_brute_force(edges, n):\n    best_cut_value = 0\n    best_partition = None\n    for i in range(1 << n):\n        set_A = {j for j in range(n) if i & (1 << j)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n        if cut_value > best_cut_value:\n            best_cut_value = cut_value\n            best_partition = (set_A, set_B)\n    return best_cut_value, best_partition\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, partition = maximum_cut_brute_force(edges, 4)""",0
"""def maximum_cut_greedy(edges, n):\n    set_A = set()\n    set_B = set(range(n))\n    for node in range(n):\n        if sum(1 for u, v in edges if u == node and v in set_A) > sum(1 for u, v in edges if u == node and v in set_B):\n            set_B.add(node)\n        else:\n            set_A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, part_A, part_B = maximum_cut_greedy(edges, 4)""",0
"""def maximal_independent_set(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = maximal_independent_set(4, edges)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""def independent_set_greedy(n, edges):\n    independent_set = set()\n    sorted_nodes = sorted(range(n), key=lambda node: sum(1 for u, v in edges if u == node or v == node))\n    for node in sorted_nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = independent_set_greedy(4, edges)""",1
"""def tsp_brute_force(cost_matrix):\n    from itertools import permutations\n    n = len(cost_matrix)\n    min_cost = float('inf')\n    best_route = None\n    for route in permutations(range(n)):\n        cost = sum(cost_matrix[route[i]][route[i+1]] for i in range(n-1)) + cost_matrix[route[-1]][route[0]]\n        if cost < min_cost:\n            min_cost = cost\n            best_route = route\n    return min_cost, best_route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\nmin_cost, best_route = tsp_brute_force(cost_matrix)""",2
"""def maximum_cut_heuristic(n, edges):\n    # Heuristic approach for Maximum Cut\n    set_A, set_B = set(), set(range(n))\n    while set_B:\n        node = set_B.pop()\n        if sum(1 for u, v in edges if u == node and v in set_A) > sum(1 for u, v in edges if u == node and v in set_B):\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, set_A, set_B = maximum_cut_heuristic(4, edges)""",0
"""def maximum_cut_random(n, edges):\n    import random\n    # Randomized approach for Maximum Cut\n    set_A, set_B = set(), set()\n    for i in range(n):\n        if random.random() > 0.5:\n            set_A.add(i)\n        else:\n            set_B.add(i)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, set_A, set_B = maximum_cut_random(4, edges)""",0
"""def maximal_independent_set_backtrack(n, edges):\n    # Backtracking approach to find the Maximal Independent Set\n    best_set = set()\n    def backtrack(node, independent_set):\n        nonlocal best_set\n        if node == n:\n            if len(independent_set) > len(best_set):\n                best_set = independent_set.copy()\n            return\n        # Option 1: Include node\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n            backtrack(node + 1, independent_set)\n            independent_set.remove(node)\n        # Option 2: Exclude node\n        backtrack(node + 1, independent_set)\n    backtrack(0, set())\n    return best_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = maximal_independent_set_backtrack(4, edges)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""def maximal_independent_set_approx(n, edges):\n    # Approximation algorithm for MIS\n    independent_set = set()\n    nodes = set(range(n))\n    while nodes:\n        node = nodes.pop()\n        independent_set.add(node)\n        neighbors = {v for u, v in edges if u == node}\n        nodes -= neighbors\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = maximal_independent_set_approx(4, edges)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"def tsp_nearest_neighbor(cost_matrix):\n    # Nearest Neighbor heuristic for TSP\n    n = len(cost_matrix)\n    visited = [False] * n\n    route = [0]\n    visited[0] = True\n    total_cost = 0\n    current = 0\n    for _ in range(n - 1):\n        next_city = min((city for city in range(n) if not visited[city]), key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        visited[next_city] = True\n        current = next_city\n    total_cost += cost_matrix[current][0]\n    return total_cost, route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_nearest_neighbor(cost_matrix)",2
"def tsp_simulated_annealing(cost_matrix):\n    import random, math\n    # Simulated Annealing for TSP\n    n = len(cost_matrix)\n    current_route = list(range(n))\n    random.shuffle(current_route)\n    current_cost = sum(cost_matrix[current_route[i]][current_route[i+1]] for i in range(n-1)) + cost_matrix[current_route[-1]][current_route[0]]\n    temp = 1000\n    cooling_rate = 0.95\n    while temp > 1:\n        new_route = current_route[:]\n        i, j = random.sample(range(n), 2)\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_cost = sum(cost_matrix[new_route[i]][new_route[i+1]] for i in range(n-1)) + cost_matrix[new_route[-1]][new_route[0]]\n        if new_cost < current_cost or math.exp((current_cost - new_cost) / temp) > random.random():\n            current_route = new_route\n            current_cost = new_cost\n        temp *= cooling_rate\n    return current_cost, current_route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_simulated_annealing(cost_matrix)",2
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(n))\n    route = [0]\n    unvisited.remove(0)\n    total_cost = 0\n    current_city = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current_city][city])\n        total_cost += cost_matrix[current_city][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current_city = next_city\n    total_cost += cost_matrix[route[-1]][route[0]]\n    return total_cost, route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_greedy(cost_matrix)",2
"def maximum_cut_quick(edges, n):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B",0
"def maximum_cut_simple(n, edges):\n    set_A, set_B = set(), set()\n    for node in range(n):\n        if node % 2 == 0:\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B",0
"def independent_set_quick(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def independent_set_random(n, edges):\n    from random import shuffle\n    nodes = list(range(n))\n    shuffle(nodes)\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def tsp_approx(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"def tsp_greedy_short(cost_matrix):\n    n = len(cost_matrix)\n    route, total_cost = [0], 0\n    current = 0\n    for _ in range(1, n):\n        next_city = min(range(n), key=lambda city: cost_matrix[current][city] if city not in route else float('inf'))\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"def max_cut_random(edges, n):\n    import random\n    A, B = set(), set()\n    for i in range(n):\n        if random.random() > 0.5:\n            A.add(i)\n        else:\n            B.add(i)\n    return sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A)), A, B",0
"def max_cut_with_weights(edges, n):\n    A, B = set(), set(range(n))\n    cut_value = 0\n    for u, v, w in edges:\n        if (u in A and v in B) or (u in B and v in A):\n            cut_value += w\n    return cut_value, A, B",0
"def max_cut_bitmask(edges, n):\n    best_cut, best_partition = 0, None\n    for i in range(1 << n):\n        A = {j for j in range(n) if i & (1 << j)}\n        B = set(range(n)) - A\n        cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n        if cut_value > best_cut:\n            best_cut, best_partition = cut_value, (A, B)\n    return best_cut, best_partition",0
"def max_cut_alternate_assignment(edges, n):\n    A, B = set(), set()\n    for i in range(n):\n        if i % 2 == 0:\n            A.add(i)\n        else:\n            B.add(i)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B",0
"def max_cut_nearest_neighbor(edges, n):\n    A, B = {0}, set(range(1, n))\n    for u, v in edges:\n        if u in A and v in B:\n            B.remove(v)\n            A.add(v)\n        elif u in B and v in A:\n            A.remove(v)\n            B.add(v)\n    return sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A)), A, B",0
"def independent_set_random(n, edges):\n    from random import shuffle\n    nodes = list(range(n))\n    shuffle(nodes)\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def independent_set_backtracking(n, edges):\n    def is_valid(independent_set, node):\n        return all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, independent_set):\n        if node == n:\n            return independent_set\n        if is_valid(independent_set, node):\n            new_set = independent_set.copy()\n            new_set.add(node)\n            return backtrack(node + 1, new_set)\n        return backtrack(node + 1, independent_set)\n    return backtrack(0, set())",1
"def independent_set_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    sorted_nodes = sorted(range(n), key=lambda x: degree[x])\n    independent_set = set()\n    for node in sorted_nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def independent_set_greedy(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def independent_set_greedy_weighted(n, edges, weights):\n    independent_set = set()\n    for node in sorted(range(n), key=lambda x: weights[x]):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def tsp_dynamic_programming(cost_matrix):\n    n = len(cost_matrix)\n    dp = [[float('inf')] * (1 << n) for _ in range(n)]\n    dp[0][1] = 0\n    for mask in range(1 << n):\n        for u in range(n):\n            if not (mask & (1 << u)):\n                continue\n            for v in range(n):\n                if mask & (1 << v):\n                    dp[v][mask] = min(dp[v][mask], dp[u][mask ^ (1 << v)] + cost_matrix[u][v])\n    return min(dp[i][(1 << n) - 1] + cost_matrix[i][0] for i in range(1, n))",2
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"def tsp_nearest_neighbor(cost_matrix):\n    n = len(cost_matrix)\n    visited = [False] * n\n    route = [0]\n    visited[0] = True\n    total_cost = 0\n    current = 0\n    for _ in range(n - 1):\n        next_city = min((city for city in range(n) if not visited[city]), key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        visited[next_city] = True\n        current = next_city\n    total_cost += cost_matrix[current][0]\n    return total_cost, route",2
"def tsp_simulated_annealing(cost_matrix):\n    import random, math\n    n = len(cost_matrix)\n    current_route = list(range(n))\n    random.shuffle(current_route)\n    current_cost = sum(cost_matrix[current_route[i]][current_route[i+1]] for i in range(n-1)) + cost_matrix[current_route[-1]][current_route[0]]\n    temp = 1000\n    cooling_rate = 0.95\n    while temp > 1:\n        new_route = current_route[:]\n        i, j = random.sample(range(n), 2)\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_cost = sum(cost_matrix[new_route[i]][new_route[i+1]] for i in range(n-1)) + cost_matrix[new_route[-1]][new_route[0]]\n        if new_cost < current_cost or math.exp((current_cost - new_cost) / temp) > random.random():\n            current_route = new_route\n            current_cost = new_cost\n        temp *= cooling_rate\n    return current_cost, current_route",2
"def tsp_approx(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"import networkx as nx\n\ndef maximum_cut_greedy_networkx(G):\n    set_A, set_B = set(), set(G.nodes)\n    for node in G.nodes:\n        if sum(1 for neighbor in G.neighbors(node) if neighbor in set_A) > sum(1 for neighbor in G.neighbors(node) if neighbor in set_B):\n            set_B.add(node)\n        else:\n            set_A.add(node)\n    cut_value = sum(1 for u, v in G.edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nmaximum_cut_greedy_networkx(G)",0
"def maximum_cut_randomized(edges, n):\n    import random\n    set_A, set_B = set(), set()\n    for i in range(n):\n        if random.random() > 0.5:\n            set_A.add(i)\n        else:\n            set_B.add(i)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in B and v in A)), set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nmaximum_cut_randomized(edges, 4)",0
"def maximum_cut_bitmask(edges, n):\n    best_cut, best_partition = 0, None\n    for mask in range(1 << n):\n        set_A = {i for i in range(n) if mask & (1 << i)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in B and v in A))\n        if cut_value > best_cut:\n            best_cut, best_partition = cut_value, (set_A, set_B)\n    return best_cut, best_partition",0
"def maximum_cut_degree_based(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    A, B = set(), set()\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        if len(A) <= len(B):\n            A.add(node)\n        else:\n            B.add(node)\n    return sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A)), A, B",0
"import networkx as nx\n\ndef maximum_cut_brute_force_networkx(G):\n    from itertools import combinations\n    best_cut = 0\n    best_partition = None\n    for cut in combinations(G.nodes, len(G)//2):\n        A = set(cut)\n        B = set(G.nodes) - A\n        cut_value = sum(1 for u, v in G.edges if (u in A and v in B) or (u in B and v in A))\n        if cut_value > best_cut:\n            best_cut = cut_value\n            best_partition = A, B\n    return best_cut, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nmaximum_cut_brute_force_networkx(G)",0
"import networkx as nx\n\ndef independent_set_greedy_networkx(G):\n    independent_set = set()\n    for node in G.nodes:\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nindependent_set_greedy_networkx(G)",1
"def independent_set_greedy(edges, n):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_greedy(edges, 4)",1
"def independent_set_random(n, edges):\n    from random import shuffle\n    nodes = list(range(n))\n    shuffle(nodes)\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_random(n, edges)",1
"import networkx as nx\n\ndef independent_set_backtracking_networkx(G):\n    def is_valid_set(independent_set, node):\n        return all(neighbor not in independent_set for neighbor in G.neighbors(node))\n    def backtrack(node, independent_set):\n        if node == len(G):\n            return independent_set\n        if is_valid_set(independent_set, node):\n            new_set = independent_set.copy()\n            new_set.add(node)\n            return backtrack(node + 1, new_set)\n        return backtrack(node + 1, independent_set)\n    return backtrack(0, set())\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nindependent_set_backtracking_networkx(G)",1
"def independent_set_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    independent_set = set()\n    for node in sorted(range(n), key=lambda x: degree[x]):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_degree_heuristic(n, edges)",1
"import networkx as nx\n\ndef tsp_brute_force_networkx(G):\n    from itertools import permutations\n    best_cost = float('inf')\n    best_route = None\n    for route in permutations(G.nodes):\n        cost = sum(G[route[i]][route[i+1]]['weight'] for i in range(len(route) - 1)) + G[route[-1]][route[0]]['weight']\n        if cost < best_cost:\n            best_cost = cost\n            best_route = route\n    return best_cost, best_route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\ntsp_brute_force_networkx(G)",2
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ntsp_greedy(cost_matrix)",2
"def tsp_simulated_annealing(cost_matrix):\n    import random, math\n    n = len(cost_matrix)\n    current_route = list(range(n))\n    random.shuffle(current_route)\n    current_cost = sum(cost_matrix[current_route[i]][current_route[i+1]] for i in range(n-1)) + cost_matrix[current_route[-1]][current_route[0]]\n    temp = 1000\n    cooling_rate = 0.95\n    while temp > 1:\n        new_route = current_route[:]\n        i, j = random.sample(range(n), 2)\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_cost = sum(cost_matrix[new_route[i]][new_route[i+1]] for i in range(n-1)) + cost_matrix[new_route[-1]][new_route[0]]\n        if new_cost < current_cost or math.exp((current_cost - new_cost) / temp) > random.random():\n            current_route = new_route\n            current_cost = new_cost\n        temp *= cooling_rate\n    return current_cost, current_route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ntsp_simulated_annealing(cost_matrix)",2
"import networkx as nx\n\ndef tsp_nearest_neighbor_networkx(G):\n    visited = [False] * len(G)\n    route = [0]\n    visited[0] = True\n    total_cost = 0\n    current = 0\n    for _ in range(len(G) - 1):\n        next_city = min((city for city in range(len(G)) if not visited[city]), key=lambda city: G[current][city]['weight'])\n        total_cost += G[current][next_city]['weight']\n        route.append(next_city)\n        visited[next_city] = True\n        current = next_city\n    total_cost += G[route[-1]][route[0]]['weight']\n    return total_cost, route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\ntsp_nearest_neighbor_networkx(G)",2
"def clique_brute_force(n, edges):\n    from itertools import combinations\n    max_clique = []\n    for k in range(2, n+1):\n        for subset in combinations(range(n), k):\n            if all((u, v) in edges or (v, u) in edges for u in subset for v in subset if u != v):\n                if len(subset) > len(max_clique):\n                    max_clique = subset\n    return max_clique",3
"def clique_greedy(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique",3
"import networkx as nx\n\ndef clique_networkx_brute_force(G):\n    from itertools import combinations\n    max_clique = []\n    nodes = list(G.nodes())\n    for k in range(2, len(nodes) + 1):\n        for subset in combinations(nodes, k):\n            if G.subgraph(subset).number_of_edges() == len(subset) * (len(subset) - 1) // 2:\n                if len(subset) > len(max_clique):\n                    max_clique = subset\n    return max_clique\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nclique_networkx_brute_force(G)",3
"def clique_greedy_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    clique = set()\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique",3
"def clique_randomized(n, edges):\n    import random\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    clique = set()\n    for node in nodes:\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique",3
"import networkx as nx\n\ndef clique_networkx_greedy(G):\n    clique = set()\n    for node in G.nodes():\n        if all(neighbor in clique or (G.has_edge(node, neighbor)) for neighbor in G.neighbors(node)):\n            clique.add(node)\n    return clique\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nclique_networkx_greedy(G)",3
"def clique_bitmask(n, edges):\n    max_clique = []\n    for mask in range(1 << n):\n        subset = [i for i in range(n) if mask & (1 << i)]\n        if all((u, v) in edges or (v, u) in edges for u in subset for v in subset if u != v):\n            if len(subset) > len(max_clique):\n                max_clique = subset\n    return max_clique",3
"def clique_backtracking(n, edges):\n    def is_clique(nodes):\n        return all((u, v) in edges or (v, u) in edges for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == n:\n            return current_clique\n        if is_clique(current_clique + [node]):\n            with_node = backtrack(node + 1, current_clique + [node])\n            without_node = backtrack(node + 1, current_clique)\n            return max(with_node, without_node, key=len)\n        return backtrack(node + 1, current_clique)\n    return backtrack(0, [])",3
"import networkx as nx\n\ndef clique_networkx_backtracking(G):\n    def is_clique(nodes):\n        return all(G.has_edge(u, v) for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == len(G.nodes):\n            return current_clique\n        if is_clique(current_clique + [node]):\n            with_node = backtrack(node + 1, current_clique + [node])\n            without_node = backtrack(node + 1, current_clique)\n            return max(with_node, without_node, key=len)\n        return backtrack(node + 1, current_clique)\n    return backtrack(0, [])\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nclique_networkx_backtracking(G)",3
"def clique_approximate(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique",3
"def greedy_kcolor_adj_matrix(adj_matrix, k):\n    n = len(adj_matrix)\n    colors = [-1] * n\n    v = 0\n    while v < n:\n        used = set()\n        u = 0\n        while u < n:\n            if adj_matrix[v][u] == 1 and colors[u] != -1:\n                used.add(colors[u])\n            u += 1\n        c = 0\n        while c < k and c in used:\n            c += 1\n        if c == k:\n            raise ValueError('k-coloring failed at vertex {}'.format(v))\n        colors[v] = c\n        v += 1\n    return colors\n\nadj = [\n    [0,1,1,0],\n    [1,0,1,1],\n    [1,1,0,1],\n    [0,1,1,0]\n]\nprint(greedy_kcolor_adj_matrix(adj, 3))",4
"def kcolor_backtracking(adj_list, k):\n    n = len(adj_list)\n    colors = [-1] * n\n\n    def is_safe(v, col):\n        idx = 0\n        neighbors = adj_list[v]\n        while idx < len(neighbors):\n            u = neighbors[idx]\n            if colors[u] == col:\n                return False\n            idx += 1\n        return True\n\n    def assign_color(v):\n        if v == n:\n            return True\n        c = 0\n        while c < k:\n            if is_safe(v, c):\n                colors[v] = c\n                if assign_color(v + 1):\n                    return True\n                colors[v] = -1\n            c += 1\n        return False\n\n    if not assign_color(0):\n        raise ValueError('No {}-coloring exists'.format(k))\n    return colors\n\nadj_list = {\n    0: [1,2],\n    1: [0,2,3],\n    2: [0,1,3],\n    3: [1,2]\n}\nprint(kcolor_backtracking(adj_list, 3))",4
"def kcolor_matrix_local_search(adj_matrix, k, max_iter=50):\n    n = len(adj_matrix)\n    colors = [i % k for i in range(n)]  # initial pattern\n\n    def conflicts(v, col):\n        cnt = 0\n        u = 0\n        while u < n:\n            if adj_matrix[v][u] == 1 and colors[u] == col:\n                cnt += 1\n            u += 1\n        return cnt\n\n    it = 0\n    while it < max_iter:\n        changed = False\n        v = 0\n        while v < n:\n            best_col = colors[v]\n            best_conf = conflicts(v, best_col)\n            c = 0\n            while c < k:\n                if c != colors[v]:\n                    c_conf = conflicts(v, c)\n                    if c_conf < best_conf:\n                        best_conf = c_conf\n                        best_col = c\n                c += 1\n            if best_col != colors[v]:\n                colors[v] = best_col\n                changed = True\n            v += 1\n        if not changed:\n            break\n        it += 1\n    return colors\n\nadj = [\n    [0,1,0,1,0],\n    [1,0,1,0,1],\n    [0,1,0,1,0],\n    [1,0,1,0,1],\n    [0,1,0,1,0]\n]\nprint(kcolor_matrix_local_search(adj, 3))",4
"def kcolor_incidence_edges(edges, n, k):\n    # build adjacency from edge list\n    adj = {i: [] for i in range(n)}\n    e_idx = 0\n    while e_idx < len(edges):\n        u, v = edges[e_idx]\n        adj[u].append(v)\n        adj[v].append(u)\n        e_idx += 1\n\n    colors = [-1] * n\n    v = 0\n    while v < n:\n        used = set()\n        ns = adj[v]\n        j = 0\n        while j < len(ns):\n            u = ns[j]\n            if colors[u] != -1:\n                used.add(colors[u])\n            j += 1\n        c = 0\n        while c < k and c in used:\n            c += 1\n        if c == k:\n            raise ValueError('Cannot color vertex {}'.format(v))\n        colors[v] = c\n        v += 1\n    return colors\n\nedges = [(0,1),(1,2),(2,3),(3,0),(1,3),(3,4)]\nprint(kcolor_incidence_edges(edges, 5, 3))",4
"def kcolor_backtrack_partial(adj_list, k):\n    # variant with vertex ordering and while-based neighbor checks\n    order = list(adj_list.keys())\n    n = len(order)\n    colors = {v: -1 for v in order}\n\n    def safe(v, col):\n        ns = adj_list[v]\n        i = 0\n        while i < len(ns):\n            u = ns[i]\n            if colors[u] == col:\n                return False\n            i += 1\n        return True\n\n    def dfs(pos):\n        if pos == n:\n            return True\n        v = order[pos]\n        c = 0\n        while c < k:\n            if safe(v, c):\n                colors[v] = c\n                if dfs(pos + 1):\n                    return True\n                colors[v] = -1\n            c += 1\n        return False\n\n    if not dfs(0):\n        raise RuntimeError('No {}-coloring found'.format(k))\n    return colors\n\nadj = {\n    0: [1,2,3],\n    1: [0,2],\n    2: [0,1,3],\n    3: [0,2]\n}\nprint(kcolor_backtrack_partial(adj, 3))",4
"def kcolor_small_cycle(k):\n    # simple k-coloring for a 6-cycle using while-only logic\n    n = 6\n    adj = {\n        0: [1,5],\n        1: [0,2],\n        2: [1,3],\n        3: [2,4],\n        4: [3,5],\n        5: [0,4]\n    }\n    colors = {v: -1 for v in adj}\n\n    v_list = list(adj.keys())\n    idx = 0\n    while idx < len(v_list):\n        v = v_list[idx]\n        forbidden = set()\n        ns = adj[v]\n        j = 0\n        while j < len(ns):\n            u = ns[j]\n            if colors[u] != -1:\n                forbidden.add(colors[u])\n            j += 1\n        c = 0\n        while c < k and c in forbidden:\n            c += 1\n        if c == k:\n            raise ValueError('Need more than {} colors'.format(k))\n        colors[v] = c\n        idx += 1\n    return colors\n\nprint(kcolor_small_cycle(3))",4
"def kcolor_with_color_sets(adj_list, k):\n    vertices = list(adj_list.keys())\n    n = len(vertices)\n    color_sets = [set() for _ in range(k)]\n    assignment = {v: None for v in vertices}\n\n    i = 0\n    while i < n:\n        v = vertices[i]\n        chosen = None\n        c = 0\n        while c < k:\n            valid = True\n            ns = adj_list[v]\n            j = 0\n            while j < len(ns):\n                u = ns[j]\n                if assignment[u] == c:\n                    valid = False\n                    break\n                j += 1\n            if valid:\n                chosen = c\n                break\n            c += 1\n        if chosen is None:\n            raise ValueError('k-coloring failed')\n        assignment[v] = chosen\n        color_sets[chosen].add(v)\n        i += 1\n    return assignment, color_sets\n\nadj = {\n    0: [1,4],\n    1: [0,2],\n    2: [1,3,4],\n    3: [2],\n    4: [0,2]\n}\nprint(kcolor_with_color_sets(adj, 3))",4
"def kcolor_matrix_scan(adj_matrix, k):\n    n = len(adj_matrix)\n    colors = [-1] * n\n\n    v = 0\n    while v < n:\n        forbidden = [False] * k\n        u = 0\n        while u < n:\n            if adj_matrix[v][u] == 1 and colors[u] != -1:\n                c = colors[u]\n                if 0 <= c < k:\n                    forbidden[c] = True\n            u += 1\n        c = 0\n        while c < k and forbidden[c]:\n            c += 1\n        if c == k:\n            raise ValueError('Vertex {} cannot be colored'.format(v))\n        colors[v] = c\n        v += 1\n    return colors\n\nadj = [\n    [0,1,0,1,0,0],\n    [1,0,1,0,1,0],\n    [0,1,0,1,0,1],\n    [1,0,1,0,1,0],\n    [0,1,0,1,0,1],\n    [0,0,1,0,1,0]\n]\nprint(kcolor_matrix_scan(adj, 3))",4
"def kcolor_with_explicit_stack(adj_list, k):\n    # manual stack-based DFS for coloring\n    vertices = list(adj_list.keys())\n    colors = {v: -1 for v in vertices}\n    stack = [(vertices[0], 0)]\n\n    while len(stack) > 0:\n        v, start_color = stack.pop()\n        if colors[v] != -1:\n            continue\n        c = start_color\n        chosen = None\n        while c < k:\n            ok = True\n            ns = adj_list[v]\n            i = 0\n            while i < len(ns):\n                u = ns[i]\n                if colors[u] == c:\n                    ok = False\n                    break\n                i += 1\n            if ok:\n                chosen = c\n                break\n            c += 1\n        if chosen is None:\n            raise ValueError('Stack-based coloring failed')\n        colors[v] = chosen\n        ns2 = adj_list[v]\n        j = 0\n        while j < len(ns2):\n            u = ns2[j]\n            if colors[u] == -1:\n                stack.append((u, 0))\n            j += 1\n    return colors\n\nadj = {\n    0: [1,2],\n    1: [0,3],\n    2: [0,3],\n    3: [1,2,4],\n    4: [3]\n}\nprint(kcolor_with_explicit_stack(adj, 3))",4
"def kcoloring_dfs(n, edges, k):\n    def dfs(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v]):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * n)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_dfs(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_dfs(G, k):\n    def dfs(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for neighbor in G.neighbors(node)):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * len(G.nodes))\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_dfs(G, 3)",4
"def kcoloring_backtracking(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_backtracking(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy(G, k):\n    colors = {}\n    for node in G.nodes():\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_greedy(G, 3)\nprint(colors)",4
"def kcoloring_random(n, edges, k):\n    import random\n    colors = [-1] * n\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    for node in nodes:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v] if colors[neighbor] != -1}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_random(4, edges, 3)\nprint(colors)",4
"def kcoloring_sequential(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_sequential(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_backtracking(G, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for neighbor in G.neighbors(node))\n    def backtrack(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * len(G.nodes))\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_backtracking(G, 3)\nprint(colors)",4
"def kcoloring_greedy_degree_heuristic(n, edges, k):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    colors = [-1] * n\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_greedy_degree_heuristic(4, edges, 3)\nprint(colors)",4
"def kcoloring_dfs(n, edges, k):\n    def dfs(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v]):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * n)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_dfs(4, edges, 3)\nprint(colors)",4
"import random\n\ndef kcoloring_simulated_annealing(n, edges, k, max_steps=1000):\n    colors = [random.choice(range(k)) for _ in range(n)]\n    temperature = 1000\n    def count_conflicts():\n        return sum(1 for u, v in edges if colors[u] == colors[v])\n    for _ in range(max_steps):\n        if count_conflicts() == 0:\n            return colors\n        node = random.choice(range(n))\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            new_color = random.choice(list(available_colors))\n            current_conflicts = count_conflicts()\n            colors[node] = new_color\n            if count_conflicts() >= current_conflicts and random.random() > (1.0 / temperature):\n                colors[node] = new_color  # Revert to previous\n        temperature *= 0.95\n    return None\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_simulated_annealing(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_dfs(G, k):\n    def dfs(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for neighbor in G.neighbors(node)):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * len(G.nodes))\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_dfs(G, 3)\nprint(colors)",4
"def kcoloring_custom_order(n, edges, k):\n    custom_order = [0, 3, 1, 2]  # Some arbitrary custom order\n    colors = [-1] * n\n    for node in custom_order:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_custom_order(4, edges, 3)\nprint(colors)",4
"def max_cut_brute_force(edges, n):\n    best_cut_value = 0\n    best_partition = None\n    for i in range(1 << n):\n        set_A = {j for j in range(n) if i & (1 << j)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n        if cut_value > best_cut_value:\n            best_cut_value = cut_value\n            best_partition = (set_A, set_B)\n    return best_cut_value, best_partition\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, partition = max_cut_brute_force(edges, 4)\nprint(cut_value, partition)",0
"def max_cut_random(n, edges):\n    import random\n    set_A, set_B = set(), set()\n    for node in range(n):\n        if random.random() > 0.5:\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, part_A, part_B = max_cut_random(4, edges)\nprint(cut_value, part_A, part_B)",0
"def mis_greedy(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = mis_greedy(4, edges)\nprint(independent_set)",1
"def mis_backtracking(n, edges):\n    def is_valid(independent_set, node):\n        return all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, current_set):\n        if node == n:\n            return current_set\n        with_node = backtrack(node + 1, current_set + [node]) if is_valid(current_set, node) else []\n        without_node = backtrack(node + 1, current_set)\n        return max(with_node, without_node, key=len)\n    return backtrack(0, [])\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = mis_backtracking(4, edges)\nprint(independent_set)",1
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_greedy(cost_matrix)\nprint(cost, route)",2
"def tsp_brute_force(cost_matrix):\n    from itertools import permutations\n    n = len(cost_matrix)\n    min_cost = float('inf')\n    best_route = None\n    for route in permutations(range(n)):\n        cost = sum(cost_matrix[route[i]][route[i+1]] for i in range(n-1)) + cost_matrix[route[-1]][route[0]]\n        if cost < min_cost:\n            min_cost = cost\n            best_route = route\n    return min_cost, best_route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\nmin_cost, route = tsp_brute_force(cost_matrix)\nprint(min_cost, route)",2
"def clique_backtracking(n, edges):\n    def is_clique(nodes):\n        return all((u, v) in edges or (v, u) in edges for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == n:\n            return current_clique\n        with_node = backtrack(node + 1, current_clique + [node]) if is_clique(current_clique + [node]) else []\n        without_node = backtrack(node + 1, current_clique)\n        return max(with_node, without_node, key=len)\n    return backtrack(0, [])\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)]\nclique = clique_backtracking(4, edges)\nprint(clique)",3
"def clique_greedy(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)]\nclique = clique_greedy(4, edges)\nprint(clique)",3
"def kcoloring_greedy(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_greedy(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy(G, k):\n    colors = {}\n    for node in G.nodes():\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_greedy(G, 3)\nprint(colors)",4
"def trial_division_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 56\nfactors = trial_division_factorization(n)\nprint(factors)",5
"def fermat_factorization(n):\n    if n % 2 == 0:\n        return [2, n // 2]\n    a = int(n**0.5) + 1\n    b2 = a*a - n\n    while int(b2**0.5)**2 != b2:\n        a += 1\n        b2 = a*a - n\n    b = int(b2**0.5)\n    return [a - b, a + b]\n\n# Input data\nn = 5959\nfactors = fermat_factorization(n)\nprint(factors)",5
"def pollard_rho_factorization(n):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    def f(x):\n        return (x*x + 1) % n\n    x, y, d = 2, 2, 1\n    while d == 1:\n        x = f(x)\n        y = f(f(y))\n        d = gcd(abs(x - y), n)\n    if d == n:\n        return None\n    return [d, n // d]\n\n# Input data\nn = 8051\nfactors = pollard_rho_factorization(n)\nprint(factors)",5
"def naive_factorization(n):\n    factors = []\n    for i in range(2, n + 1):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    return factors\n\n# Input data\nn = 315\nfactors = naive_factorization(n)\nprint(factors)",5
"def pollard_rho_optimized(n):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    def f(x):\n        return (x * x + 1) % n\n    x, y, d = 2, 2, 1\n    while d == 1:\n        x = f(x)\n        y = f(f(y))\n        d = gcd(abs(x - y), n)\n    if d == n:\n        return None\n    return [d, n // d]\n\n# Input data\nn = 10403\nfactors = pollard_rho_optimized(n)\nprint(factors)",5
"def pollard_brent_factorization(n):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    y, c, m = 2, 1, 100\n    g, r, q = 1, 1, 1\n    x, ys = 0, 0\n    while g == 1:\n        x = y\n        for i in range(r):\n            y = (y * y + c) % n\n        k = 0\n        while k < r and g == 1:\n            ys = y\n            for i in range(min(m, r - k)):\n                y = (y * y + c) % n\n                q = q * abs(x - y) % n\n            g = gcd(q, n)\n            k += m\n        r *= 2\n    if g == n:\n        while True:\n            ys = (ys * ys + c) % n\n            g = gcd(abs(x - ys), n)\n            if g > 1:\n                break\n    return [g, n // g]\n\n# Input data\nn = 5897\nfactors = pollard_brent_factorization(n)\nprint(factors)",5
"def fermat_modified_factorization(n):\n    if n % 2 == 0:\n        return [2, n // 2]\n    x = int(n**0.5) + 1\n    while True:\n        y2 = x*x - n\n        y = int(y2**0.5)\n        if y*y == y2:\n            break\n        x += 1\n    return [x - y, x + y]\n\n# Input data\nn = 1369\nfactors = fermat_modified_factorization(n)\nprint(factors)",5
"def optimized_trial_division(n):\n    factors = []\n    divisor = 2\n    while n % divisor == 0:\n        factors.append(divisor)\n        n //= divisor\n    divisor = 3\n    while n > 1 and divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 2\n    if n > 1:\n        factors.append(n)\n    return factors\n\n# Input data\nn = 123456\nfactors = optimized_trial_division(n)\nprint(factors)",5
"def simple_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 1458\nfactors = simple_factorization(n)\nprint(factors)",5
"def factorization_recursive(n):\n    def recursive_division(n, divisor=2):\n        if n == 1:\n            return []\n        if n % divisor == 0:\n            return [divisor] + recursive_division(n // divisor, divisor)\n        return recursive_division(n, divisor + 1)\n    return recursive_division(n)\n\n# Input data\nn = 98\nfactors = factorization_recursive(n)\nprint(factors)",5
"def wheel_factorization(n):\n    factors = []\n    wheel = [2, 3, 5]\n    for prime in wheel:\n        while n % prime == 0:\n            factors.append(prime)\n            n //= prime\n    divisor = 7\n    step = [4, 2, 4, 2, 4, 6, 2, 6]\n    while divisor * divisor <= n:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += step.pop(0)\n            step.append(step[-1])\n    if n > 1:\n        factors.append(n)\n    return factors\n\n# Input data\nn = 2310\nfactors = wheel_factorization(n)\nprint(factors)",5
"def rho_with_random_pollard(n):\n    from random import randint\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    def f(x, n):\n        return (x*x + randint(1, 10)) % n\n    x, y, d = 2, 2, 1\n    while d == 1:\n        x = f(x, n)\n        y = f(f(y, n), n)\n        d = gcd(abs(x - y), n)\n    if d == n:\n        return None\n    return [d, n // d]\n\n# Input data\nn = 8893\nfactors = rho_with_random_pollard(n)\nprint(factors)",5
"# Python code\nimport networkx as nx\n\ndef priority_based_mis(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: (G.degree(x), x))\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nindependent_set = priority_based_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef greedy_degree_mis(G):\n    independent_set = set()\n    remaining_nodes = sorted(G.nodes(), key=lambda x: G.degree(x), reverse=True)\n    while remaining_nodes:\n        node = remaining_nodes.pop(0)\n        independent_set.add(node)\n        neighbors = set(G.neighbors(node))\n        remaining_nodes = [n for n in remaining_nodes if n not in neighbors]\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = greedy_degree_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef recursive_heuristic_mis(G, independent_set=None, remaining_nodes=None):\n    if independent_set is None:\n        independent_set = set()\n    if remaining_nodes is None:\n        remaining_nodes = set(G.nodes())\n    if not remaining_nodes:\n        return independent_set\n    node = min(remaining_nodes, key=lambda x: G.degree(x))\n    neighbors = set(G.neighbors(node))\n    new_set = independent_set | {node}\n    return recursive_heuristic_mis(G, new_set, remaining_nodes - neighbors)\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4)])\nindependent_set = recursive_heuristic_mis(G)\nprint(f""Maximal Independent Set: {independent_set}"")",1
"# Python code\nimport networkx as nx\n\ndef depth_first_mis(G):\n    independent_set = set()\n    visited_nodes = set()\n    def dfs(node):\n        if node not in visited_nodes:\n            visited_nodes.add(node)\n            independent_set.add(node)\n            for neighbor in G.neighbors(node):\n                visited_nodes.add(neighbor)\n    for start_node in G.nodes():\n        dfs(start_node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 5), (5, 6), (6, 1)])\nresult_set = depth_first_mis(G)\nprint(f""Maximal Independent Set: {result_set}"")",1
"# Python code\nimport networkx as nx\nimport random\n\ndef shuffled_greedy_mis(G):\n    independent_set = set()\n    nodes = list(G.nodes())\n    random.shuffle(nodes)\n    for node in nodes:\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 2), (2, 3), (3, 5), (5, 6), (6, 0)])\nmis_set = shuffled_greedy_mis(G)\nprint(f""Maximal Independent Set: {mis_set}"")",1
"# Python code\nimport networkx as nx\nimport random\n\ndef random_degree_priority_mis(G):\n    independent_set = set()\n    nodes = sorted(G.nodes(), key=lambda n: G.degree(n), reverse=True)\n    random.shuffle(nodes)\n    while nodes:\n        node = nodes.pop(0)\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 4), (4, 5), (5, 3), (3, 1)])\nmis_set = random_degree_priority_mis(G)\nprint(f""Maximal Independent Set: {mis_set}"") ",1
"# Python code\nimport networkx as nx\nimport random\n\ndef random_degree_priority_mis(G):\n    independent_set = set()\n    nodes = sorted(G.nodes(), key=lambda n: G.degree(n), reverse=True)\n    random.shuffle(nodes)\n    while nodes:\n        node = nodes.pop(0)\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 4), (4, 5), (5, 3), (3, 1)])\nmis_set = random_degree_priority_mis(G)\nprint(f""Maximal Independent Set: {mis_set}"") ",1
"import networkx as nx\n\ndef recursive_mis(graph, current_set=None, remaining=None):\n    if current_set is None:\n        current_set = set()\n    if remaining is None:\n        remaining = set(graph.nodes())\n    if not remaining:\n        return current_set\n    node = remaining.pop()\n    neighbors = set(graph.neighbors(node))\n    new_set = current_set | {node}\n    return recursive_mis(graph, new_set, remaining - neighbors)\n\ngraph = nx.Graph()\ngraph.add_edges_from([(0, 2), (2, 3), (3, 1), (1, 0)])\nresult = recursive_mis(graph)\nprint(f""Maximal Independent Set: {result}"") ",1
"# Python code\nimport networkx as nx\nimport random\n\ndef randomized_maxcut_random(G, iterations=500):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n        if cut_value > max_cut_value:\n            max_cut_value = cut_value\n            best_partition = (partition_A, partition_B)\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 4), (4, 3), (3, 0)])\nmax_cut, best_part = randomized_maxcut_random(G)\nprint(f""Maximum Cut: {max_cut}"")\nprint(f""Best Partition: {best_part}"") ",0
"# Python code\nimport networkx as nx\n\ndef greedy_maxcut_simple(G):\n    partition_A = set()\n    partition_B = set(G.nodes())\n    for node in G.nodes():\n        if sum(1 for neighbor in G.neighbors(node) if neighbor in partition_A) > sum(1 for neighbor in G.neighbors(node) if neighbor in partition_B):\n            partition_B.add(node)\n        else:\n            partition_A.add(node)\n    max_cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return max_cut_value, partition_A, partition_B\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value, part_A, part_B = greedy_maxcut_simple(G)\nprint(f""Maximum Cut Value: {cut_value}"")",0
"# Python code\nimport networkx as nx\n\ndef maximum_cut(G):\n    cut_value, partition = nx.algorithms.approximation.maxcut.maximum_cut(G)\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = maximum_cut(G)\nprint(result)",1
"""import networkx as nx\nimport random\n\ndef randomized_maxcut(G, iterations=1000):\n    max_cut_value = 0\n    best_partition = None\n    nodes = list(G.nodes())\n    for _ in range(iterations):\n        partition_A = set(random.sample(nodes, len(nodes) // 2))\n        partition_B = set(nodes) - partition_A\n        cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return max_cut_value, best_partition\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0)])\nmax_cut_value, best_partition = randomized_maxcut(G)\nprint(f\""Maximum cut value: {max_cut_value}\"")\nprint(f\""Best partition: {best_partition}\"")""",1
"""# Python code\nimport networkx as nx\n\ndef independent_set(G):\n    independent_set = set()\n    for node in G.nodes():\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = independent_set(G)\nprint(f\""Independent Set: {result}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef maximum_cut_randomized(G):\n    # Randomized approach for solving Maximum Cut\n    import random\n    partition_A = set(random.sample(G.nodes(), len(G.nodes()) // 2))\n    partition_B = set(G.nodes()) - partition_A\n    cut_value = sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n    return cut_value\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)])\ncut_value = maximum_cut_randomized(G)\nprint(f\""Maximum Cut Value: {cut_value}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef independent_set_heuristic(G):\n    # Use heuristic approach to find independent set\n    independent_set = set()\n    for node in G.nodes():\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 2)])\nresult = independent_set_heuristic(G)\nprint(f\""Independent Set: {result}\"")""",1
"""import networkx as nx\n\ndef max_cut_using_simulated_annealing(G):\n    # Simulated Annealing approach for Maximum Cut\n    import random, math\n    nodes = list(G.nodes())\n    curr_sol = set(random.sample(nodes, len(nodes) // 2))\n    best_sol = curr_sol\n    cut_val = calc_cut_value(G, curr_sol)\n    temp = 1000\n    while temp > 1:\n        new_sol = curr_sol.copy()\n        node = random.choice(list(new_sol))\n        new_sol.remove(node)\n        new_cut_val = calc_cut_value(G, new_sol)\n        if new_cut_val > cut_val or math.exp((new_cut_val - cut_val) / temp) > random.random():\n            curr_sol = new_sol\n            cut_val = new_cut_val\n            best_sol = curr_sol\n        temp *= 0.95\n    return cut_val, best_sol\n\ndef calc_cut_value(G, partition_A):\n    partition_B = set(G.nodes()) - partition_A\n    return sum(1 for u, v in G.edges() if (u in partition_A and v in partition_B) or (u in partition_B and v in partition_A))\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (4, 2)])\ncut_value, partition = max_cut_using_simulated_annealing(G)\n""",0
"""# Python code\nimport networkx as nx\n\ndef greedy_maximum_cut_algo(graph):\n    # Greedy solution to solve the Maximum Cut\n    A = set()\n    B = set(graph.nodes())\n    for n in graph.nodes():\n        if sum(1 for neighbor in graph.neighbors(n) if neighbor in A) > sum(1 for neighbor in graph.neighbors(n) if neighbor in B):\n            B.add(n)\n        else:\n            A.add(n)\n    cut_value = sum(1 for u, v in graph.edges() if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncut_value, A, B = greedy_maximum_cut_algo(G)\nprint(f\""Max Cut: {cut_value}\"")""",0
"""# Python code\nimport networkx as nx\n\ndef maximal_independent_set_dfs(graph):\n    # DFS approach to find maximal independent set\n    i_set = set()\n    visited = set()\n    def dfs(node):\n        if node not in visited:\n            visited.add(node)\n            i_set.add(node)\n            for neighbor in graph.neighbors(node):\n                visited.add(neighbor)\n    for start_node in graph.nodes():\n        dfs(start_node)\n    return i_set\n\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 5), (5, 0)])\nindependent_set = maximal_independent_set_dfs(G)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""# Python code\nimport networkx as nx\n\ndef randomized_independent_set_algorithm(G):\n    # Use randomized approach to find independent set\n    import random\n    independent_set = set()\n    remaining_nodes = list(G.nodes())\n    random.shuffle(remaining_nodes)\n    for node in remaining_nodes:\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nresult = randomized_independent_set_algorithm(G)\nprint(f\""Independent Set: {result}\"")""",1
"import networkx as nx\nfrom itertools import permutations\n\ndef tsp_brute_force(graph):\n    # Brute-force solution for TSP\n    nodes = list(graph.nodes())\n    min_cost = float('inf')\n    best_route = None\n    for route in permutations(nodes):\n        cost = sum(graph[route[i]][route[i+1]]['weight'] for i in range(len(route) - 1)) + graph[route[-1]][route[0]]['weight']\n        if cost < min_cost:\n            min_cost = cost\n            best_route = route\n    return min_cost, best_route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 8), (1, 2, 12), (2, 3, 15), (3, 0, 9)])\nmin_cost, route = tsp_brute_force(G)",2
"# Python code\nimport networkx as nx\nimport random\n\ndef tsp_greedy(graph):\n    # Greedy algorithm for TSP\n    start_node = random.choice(list(graph.nodes()))\n    unvisited = set(graph.nodes())\n    unvisited.remove(start_node)\n    route = [start_node]\n    current_node = start_node\n    total_cost = 0\n    while unvisited:\n        next_node = min(unvisited, key=lambda node: graph[current_node][node]['weight'])\n        total_cost += graph[current_node][next_node]['weight']\n        route.append(next_node)\n        unvisited.remove(next_node)\n        current_node = next_node\n    total_cost += graph[route[-1]][route[0]]['weight']\n    return total_cost, route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 11), (1, 2, 9), (2, 3, 14), (3, 0, 12)])\ncost, route = tsp_greedy(G)",2
"""def maximum_cut_heuristic(n, edges):\n    set_A, set_B = set(), set(range(n))\n    while set_B:\n        node = set_B.pop()\n        if sum(1 for u, v in edges if u == node and v in set_A) > sum(1 for u, v in edges if u == node and v in set_B):\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n    return cut_value, set_A, set_B\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, set_A, set_B = maximum_cut_heuristic(4, edges)""",0
"""def maximal_independent_set_approx(n, edges):\n    independent_set = set()\n    nodes = set(range(n))\n    while nodes:\n        node = nodes.pop()\n        independent_set.add(node)\n        neighbors = {v for u, v in edges if u == node}\n        nodes -= neighbors\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = maximal_independent_set_approx(4, edges)\nprint(f\""Maximal Independent Set: {independent_set}\"")""",1
"""def tsp_simulated_annealing(cost_matrix):\n    import random, math\n    n = len(cost_matrix)\n    current_route = list(range(n))\n    random.shuffle(current_route)\n    current_cost = sum(cost_matrix[current_route[i]][current_route[i+1]] for i in range(n-1)) + cost_matrix[current_route[-1]][current_route[0]]\n    temp = 1000\n    cooling_rate = 0.95\n    while temp > 1:\n        new_route = current_route[:]\n        i, j = random.sample(range(n), 2)\n        new_route[i], new_route[j] = new_route[j], new_route[i]\n        new_cost = sum(cost_matrix[new_route[i]][new_route[i+1]] for i in range(n-1)) + cost_matrix[new_route[-1]][new_route[0]]\n        if new_cost < current_cost or math.exp((current_cost - new_cost) / temp) > random.random():\n            current_route = new_route\n            current_cost = new_cost\n        temp *= cooling_rate\n    return current_cost, current_route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_simulated_annealing(cost_matrix)""",2
"def maxcut_bruteforce(adj):\n    n=len(adj)\n    best=-1\n    best_part=None\n    for mask in range(1<<n):\n        left=[i for i in range(n) if (mask>>i)&1]\n        right=[i for i in range(n) if not (mask>>i)&1]\n        val=0\n        for i in range(n):\n            for j in range(i+1,n):\n                if adj[i][j]!=0 and ((i in left and j in right) or (i in right and j in left)):\n                    val+=adj[i][j]\n        if val>best:\n            best=val\n            best_part=(left,right)\n    return best,best_part\n\nadj=[[0,1,1,0],[1,0,0,1],[1,0,0,1],[0,1,1,0]]\nprint(maxcut_bruteforce(adj))",0
"def independent_set_quick(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set",1
"def tsp_approx(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route",2
"def greedy_maxcut_list(adj):\n    left=set()\n    right=set()\n    for u in adj:\n        left_gain=0\n        right_gain=0\n        for v,w in adj[u]:\n            if v in left:\n                right_gain+=w\n            elif v in right:\n                left_gain+=w\n        if right_gain>left_gain:\n            right.add(u)\n        else:\n            left.add(u)\n    cut_val=0\n    for u in adj:\n        for v,w in adj[u]:\n            if u<v and ((u in left and v in right) or (u in right and v in left)):\n                cut_val+=w\n    return cut_val,(left,right)\n\nadj={0:[(1,1),(2,2)],1:[(0,1),(3,3)],2:[(0,2),(3,1)],3:[(1,3),(2,1)]}\nprint(greedy_maxcut_list(adj))",0
"def partition(n,mask):\n    l=[]; r=[]; i=0\n    while i<n:\n        if (mask>>i)&1: l.append(i)\n        else: r.append(i)\n        i+=1\n    return l,r\n\ndef bruteforce_edge_maxcut(n,edges):\n    best=-1; part=None; m=1\n    while m<(1<<n):\n        left,right=partition(n,m)\n        val=0\n        for u,v,w in edges:\n            if (u in left and v in right) or (u in right and v in left): val+=w\n        if val>best:\n            best=val\n            part=(left,right)\n        m+=1\n    return best,part\n\nedges=[(0,1,1),(1,3,1),(3,2,2),(2,0,1)]\nprint(bruteforce_edge_maxcut(4,edges))",0
"import networkx as nx\n\ndef independent_set_greedy_networkx(G):\n    independent_set = set()\n    for node in G.nodes:\n        if all(neighbor not in independent_set for neighbor in G.neighbors(node)):\n            independent_set.add(node)\n    return independent_set\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nindependent_set_greedy_networkx(G)",1
"def independent_set_random(n, edges):\n    from random import shuffle\n    nodes = list(range(n))\n    shuffle(nodes)\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_random(n, edges)",1
"import networkx as nx\n\ndef tsp_brute_force_networkx(G):\n    from itertools import permutations\n    best_cost = float('inf')\n    best_route = None\n    for route in permutations(G.nodes):\n        cost = sum(G[route[i]][route[i+1]]['weight'] for i in range(len(route) - 1)) + G[route[-1]][route[0]]['weight']\n        if cost < best_cost:\n            best_cost = cost\n            best_route = route\n    return best_cost, best_route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\ntsp_brute_force_networkx(G)",2
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ntsp_greedy(cost_matrix)",2
"import networkx as nx\n\ndef tsp_nearest_neighbor_networkx(G):\n    visited = [False] * len(G)\n    route = [0]\n    visited[0] = True\n    total_cost = 0\n    current = 0\n    for _ in range(len(G) - 1):\n        next_city = min((city for city in range(len(G)) if not visited[city]), key=lambda city: G[current][city]['weight'])\n        total_cost += G[current][next_city]['weight']\n        route.append(next_city)\n        visited[next_city] = True\n        current = next_city\n    total_cost += G[route[-1]][route[0]]['weight']\n    return total_cost, route\n\nG = nx.Graph()\nG.add_weighted_edges_from([(0, 1, 10), (1, 2, 15), (2, 3, 20), (3, 0, 25)])\ntsp_nearest_neighbor_networkx(G)",2
"def independent_set_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    independent_set = set()\n    for node in sorted(range(n), key=lambda x: degree[x]):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set_degree_heuristic(n, edges)",1
"def clique_brute_force(n, edges):\n    from itertools import combinations\n    max_clique = []\n    for k in range(2, n+1):\n        for subset in combinations(range(n), k):\n            if all((u, v) in edges or (v, u) in edges for u in subset for v in subset if u != v):\n                if len(subset) > len(max_clique):\n                    max_clique = subset\n    return max_clique",3
"import networkx as nx\n\ndef clique_networkx_greedy(G):\n    clique = set()\n    for node in G.nodes():\n        if all(neighbor in clique or (G.has_edge(node, neighbor)) for neighbor in G.neighbors(node)):\n            clique.add(node)\n    return clique\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0), (0, 2)])\nclique_networkx_greedy(G)",3
"def clique_greedy_degree_heuristic(n, edges):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    clique = set()\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_greedy_degree_heuristic(4, edges)",3
"def clique_bitmask(n, edges):\n    max_clique = []\n    for mask in range(1 << n):\n        subset = [i for i in range(n) if mask & (1 << i)]\n        if all((u, v) in edges or (v, u) in edges for u in subset for v in subset if u != v):\n            if len(subset) > len(max_clique):\n                max_clique = subset\n    return max_clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_bitmask(4, edges)",3
"import networkx as nx\n\ndef clique_networkx_backtracking(G):\n    def is_clique(nodes):\n        return all(G.has_edge(u, v) for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == len(G.nodes):\n            return current_clique\n        if is_clique(current_clique + [node]):\n            with_node = backtrack(node + 1, current_clique + [node])\n            without_node = backtrack(node + 1, current_clique)\n            return max(with_node, without_node, key=len)\n        return backtrack(node + 1, current_clique)\n    return backtrack(0, [])\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nclique_networkx_backtracking(G)",3
"def clique_approximate(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_approximate(4, edges)",3
"def clique_backtracking(n, edges):\n    def is_clique(nodes):\n        return all((u, v) in edges or (v, u) in edges for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == n:\n            return current_clique\n        if is_clique(current_clique + [node]):\n            with_node = backtrack(node + 1, current_clique + [node])\n            without_node = backtrack(node + 1, current_clique)\n            return max(with_node, without_node, key=len)\n        return backtrack(node + 1, current_clique)\n    return backtrack(0, [])\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_backtracking(4, edges)",3
"import networkx as nx\n\ndef clique_networkx_brute_force(G):\n    from itertools import combinations\n    max_clique = []\n    nodes = list(G.nodes())\n    for k in range(2, len(nodes) + 1):\n        for subset in combinations(nodes, k):\n            if G.subgraph(subset).number_of_edges() == len(subset) * (len(subset) - 1) // 2:\n                if len(subset) > len(max_clique):\n                    max_clique = subset\n    return max_clique\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nclique_networkx_brute_force(G)",3
"def clique_randomized(n, edges):\n    import random\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    clique = set()\n    for node in nodes:\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_randomized(4, edges)",3
"def clique_greedy(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique_greedy(4, edges)",3
"def kcoloring_largest_degree_first(n, edges, k):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    colors = [-1] * n\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_largest_degree_first(4, edges, 3)",4
"import random\n\ndef kcoloring_random_walk(n, edges, k):\n    colors = [-1] * n\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    for node in nodes:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_random_walk(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_largest_degree(G, k):\n    degree = {i: len(list(G.neighbors(i))) for i in G.nodes}\n    colors = {}\n    for node in sorted(G.nodes(), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_largest_degree(G, 3)",4
"def kcoloring_greedy_recursive(n, edges, k):\n    colors = [-1] * n\n    def assign_color(node):\n        if node == n:\n            return colors\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n            return assign_color(node + 1)\n        return None\n    return assign_color(0)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_greedy_recursive(4, edges, 3)",4
"import random\n\ndef kcoloring_simulated_annealing(n, edges, k, max_steps=1000):\n    colors = [random.choice(range(k)) for _ in range(n)]\n    temperature = 1000\n    def count_conflicts():\n        return sum(1 for u, v in edges if colors[u] == colors[v])\n    for _ in range(max_steps):\n        if count_conflicts() == 0:\n            return colors\n        node = random.choice(range(n))\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            new_color = random.choice(list(available_colors))\n            current_conflicts = count_conflicts()\n            colors[node] = new_color\n            if count_conflicts() >= current_conflicts and random.random() > (1.0 / temperature):\n                colors[node] = new_color  # Revert to previous\n        temperature *= 0.95\n    return None\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_simulated_annealing(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_simulated_annealing(G, k):\n    import random, math\n    colors = {node: random.choice(range(k)) for node in G.nodes()}\n    temperature = 1000\n    def count_conflicts():\n        return sum(1 for node in G.nodes() for neighbor in G.neighbors(node) if colors[node] == colors[neighbor])\n    for _ in range(1000):\n        if count_conflicts() == 0:\n            return colors\n        node = random.choice(list(G.nodes()))\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node)}\n        if available_colors:\n            new_color = random.choice(list(available_colors))\n            current_conflicts = count_conflicts()\n            colors[node] = new_color\n            if count_conflicts() >= current_conflicts and random.random() > (1.0 / temperature):\n                colors[node] = new_color  # Revert to previous\n        temperature *= 0.95\n    return None\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_simulated_annealing(G, 3)",4
"def kcoloring_backtracking_revised(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_backtracking_revised(4, edges, 3)",4
"import random\n\ndef kcoloring_random_restarts(n, edges, k, max_restarts=10):\n    def random_coloring():\n        colors = [-1] * n\n        nodes = list(range(n))\n        random.shuffle(nodes)\n        for node in nodes:\n            available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n            if available_colors:\n                colors[node] = random.choice(list(available_colors))\n        return colors\n    for _ in range(max_restarts):\n        colors = random_coloring()\n        if all(colors[node] != colors[neighbor] for u, v in edges for neighbor in [v]):\n            return colors\n    return None\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_random_restarts(4, edges, 3)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy_optimized(G, k):\n    degree = {i: len(list(G.neighbors(i))) for i in G.nodes()}\n    colors = {}\n    for node in sorted(G.nodes(), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n        else:\n            return None\n    return colors\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\nkcoloring_networkx_greedy_optimized(G, 3)",4
"def kcoloring_custom_order(n, edges, k):\n    custom_order = [0, 3, 1, 2]  # Some arbitrary custom order\n    colors = [-1] * n\n    for node in custom_order:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nkcoloring_custom_order(4, edges, 3)",4
"def kcoloring_backtracking(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_backtracking(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_greedy(G, k):\n    colors = {}\n    for node in G.nodes():\n        available_colors = set(range(k)) - {colors[neighbor] for neighbor in G.neighbors(node) if neighbor in colors}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_greedy(G, 3)\nprint(colors)",4
"def kcoloring_random(n, edges, k):\n    import random\n    colors = [-1] * n\n    nodes = list(range(n))\n    random.shuffle(nodes)\n    for node in nodes:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v] if colors[neighbor] != -1}\n        if available_colors:\n            colors[node] = random.choice(list(available_colors))\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_random(4, edges, 3)\nprint(colors)",4
"def kcoloring_sequential(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_sequential(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_backtracking(G, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for neighbor in G.neighbors(node))\n    def backtrack(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * len(G.nodes))\n\n# Input data\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_backtracking(G, 3)\nprint(colors)",4
"def kcoloring_greedy_degree_heuristic(n, edges, k):\n    degree = {i: sum(1 for u, v in edges if u == i or v == i) for i in range(n)}\n    colors = [-1] * n\n    for node in sorted(range(n), key=lambda x: degree[x], reverse=True):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_greedy_degree_heuristic(4, edges, 3)\nprint(colors)",4
"def kcoloring_dfs(n, edges, k):\n    def dfs(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v]):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * n)\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_dfs(4, edges, 3)\nprint(colors)",4
"import random\n\ndef kcoloring_simulated_annealing(n, edges, k, max_steps=1000):\n    colors = [random.choice(range(k)) for _ in range(n)]\n    temperature = 1000\n    def count_conflicts():\n        return sum(1 for u, v in edges if colors[u] == colors[v])\n    for _ in range(max_steps):\n        if count_conflicts() == 0:\n            return colors\n        node = random.choice(range(n))\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            new_color = random.choice(list(available_colors))\n            current_conflicts = count_conflicts()\n            colors[node] = new_color\n            if count_conflicts() >= current_conflicts and random.random() > (1.0 / temperature):\n                colors[node] = new_color  # Revert to previous\n        temperature *= 0.95\n    return None\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_simulated_annealing(4, edges, 3)\nprint(colors)",4
"import networkx as nx\n\ndef kcoloring_networkx_dfs(G, k):\n    def dfs(node, colors):\n        if node == len(G.nodes):\n            return colors\n        for color in range(k):\n            if all(colors[neighbor] != color for neighbor in G.neighbors(node)):\n                colors[node] = color\n                result = dfs(node + 1, colors)\n                if result:\n                    return result\n                colors[node] = -1\n        return None\n    return dfs(0, [-1] * len(G.nodes))\n\n# Input data\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 2), (2, 3), (3, 0)])\ncolors = kcoloring_networkx_dfs(G, 3)\nprint(colors)",4
"def kcoloring_custom_order(n, edges, k):\n    custom_order = [0, 3, 1, 2]  # Some arbitrary custom order\n    colors = [-1] * n\n    for node in custom_order:\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_custom_order(4, edges, 3)\nprint(colors)",4
"def trial_division_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 100\nfactors = trial_division_factorization(n)\nprint(factors)",5
"def fermat_factorization(n):\n    if n % 2 == 0:\n        return [2, n // 2]\n    a = int(n**0.5) + 1\n    b2 = a*a - n\n    while int(b2**0.5)**2 != b2:\n        a += 1\n        b2 = a*a - n\n    b = int(b2**0.5)\n    return [a - b, a + b]\n\n# Input data\nn = 10403\nfactors = fermat_factorization(n)\nprint(factors)",5
"def pollard_rho_factorization(n):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    def f(x):\n        return (x*x + 1) % n\n    x, y, d = 2, 2, 1\n    while d == 1:\n        x = f(x)\n        y = f(f(y))\n        d = gcd(abs(x - y), n)\n    if d == n:\n        return None\n    return [d, n // d]\n\n# Input data\nn = 8059\nfactors = pollard_rho_factorization(n)\nprint(factors)",5
"def naive_factorization(n):\n    factors = []\n    for i in range(2, n + 1):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    return factors\n\n# Input data\nn = 987\nfactors = naive_factorization(n)\nprint(factors)",5
"def pollard_rho_optimized(n):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    def f(x):\n        return (x * x + 1) % n\n    x, y, d = 2, 2, 1\n    while d == 1:\n        x = f(x)\n        y = f(f(y))\n        d = gcd(abs(x - y), n)\n    if d == n:\n        return None\n    return [d, n // d]\n\n# Input data\nn = 99991\nfactors = pollard_rho_optimized(n)\nprint(factors)",5
"def optimized_trial_division(n):\n    factors = []\n    divisor = 2\n    while n % divisor == 0:\n        factors.append(divisor)\n        n //= divisor\n    divisor = 3\n    while n > 1 and divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 2\n    if n > 1:\n        factors.append(n)\n    return factors\n\n# Input data\nn = 1296\nfactors = optimized_trial_division(n)\nprint(factors)",5
"def fermat_modified_factorization(n):\n    if n % 2 == 0:\n        return [2, n // 2]\n    x = int(n**0.5) + 1\n    while True:\n        y2 = x*x - n\n        y = int(y2**0.5)\n        if y*y == y2:\n            break\n        x += 1\n    return [x - y, x + y]\n\n# Input data\nn = 11521\nfactors = fermat_modified_factorization(n)\nprint(factors)",5
"def simple_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 972\nfactors = simple_factorization(n)\nprint(factors)",5
"def pollard_brent_factorization(n):\n    def gcd(x, y):\n        while y != 0:\n            x, y = y, x % y\n        return x\n    y, c, m = 2, 1, 100\n    g, r, q = 1, 1, 1\n    x, ys = 0, 0\n    while g == 1:\n        x = y\n        for i in range(r):\n            y = (y * y + c) % n\n        k = 0\n        while k < r and g == 1:\n            ys = y\n            for i in range(min(m, r - k)):\n                y = (y * y + c) % n\n                q = q * abs(x - y) % n\n            g = gcd(q, n)\n            k += m\n        r *= 2\n    if g == n:\n        while True:\n            ys = (ys * ys + c) % n\n            g = gcd(abs(x - ys), n)\n            if g > 1:\n                break\n    return [g, n // g]\n\n# Input data\nn = 7583\nfactors = pollard_brent_factorization(n)",5
"def max_cut_greedy(n, edges):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = max_cut_greedy(4, edges)\nprint(cut_value, A, B)",0
"def mis_greedy(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = mis_greedy(4, edges)\nprint(independent_set)",1
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_greedy(cost_matrix)\nprint(cost, route)",2
"def clique_greedy(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique = clique_greedy(4, edges)\nprint(clique)",3
"def kcoloring_greedy(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_greedy(4, edges, 3)\nprint(colors)",4
"def trial_division_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 120\nfactors = trial_division_factorization(n)\nprint(factors)",5
"def max_cut_brute_force(n, edges):\n    best_cut_value = 0\n    best_partition = None\n    for i in range(1 << n):\n        set_A = {j for j in range(n) if i & (1 << j)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in B and v in A))\n        if cut_value > best_cut_value:\n            best_cut_value = cut_value\n            best_partition = (set_A, set_B)\n    return best_cut_value, best_partition\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, partition = max_cut_brute_force(4, edges)\nprint(cut_value, partition)",0
"def mis_backtracking(n, edges):\n    def is_valid(independent_set, node):\n        return all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, current_set):\n        if node == n:\n            return current_set\n        with_node = backtrack(node + 1, current_set + [node]) if is_valid(current_set, node) else []\n        without_node = backtrack(node + 1, current_set)\n        return max(with_node, without_node, key=len)\n    return backtrack(0, [])\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = mis_backtracking(4, edges)\nprint(independent_set)",1
"def tsp_nearest_neighbor(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = tsp_nearest_neighbor(cost_matrix)\nprint(cost, route)",2
"def clique_backtracking(n, edges):\n    def is_clique(nodes):\n        return all((u, v) in edges or (v, u) in edges for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_clique):\n        if node == n:\n            return current_clique\n        with_node = backtrack(node + 1, current_clique + [node]) if is_clique(current_clique + [node]) else []\n        without_node = backtrack(node + 1, current_clique)\n        return max(with_node, without_node, key=len)\n    return backtrack(0, [])\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nclique = clique_backtracking(4, edges)\nprint(clique)",3
"def kcoloring_backtracking(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = kcoloring_backtracking(4, edges, 3)\nprint(colors)",4
"def partition_greedy(n, edges):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = partition_greedy(4, edges)\nprint(cut_value, A, B)",0
"def vertex_selection_greedy(n, edges):\n    selection = set()\n    for node in range(n):\n        if all(neighbor not in selection for u, v in edges if u == node for neighbor in [v]):\n            selection.add(node)\n    return selection\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nselection = vertex_selection_greedy(4, edges)\nprint(selection)",1
"def route_planning(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = route_planning(cost_matrix)\nprint(cost, route)",2
"def group_selection(n, edges):\n    group = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in group):\n            group.add(node)\n    return group\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ngroup = group_selection(4, edges)\nprint(group)",3
"def color_assignment_greedy(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = color_assignment_greedy(4, edges, 3)\nprint(colors)",4
"def factorization_trial_division(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 120\nfactors = factorization_trial_division(n)\nprint(factors)",5
"def partition_exhaustive(n, edges):\n    best_cut_value = 0\n    best_partition = None\n    for i in range(1 << n):\n        set_A = {j for j in range(n) if i & (1 << j)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in B and v in A))\n        if cut_value > best_cut_value:\n            best_cut_value = cut_value\n            best_partition = (set_A, set_B)\n    return best_cut_value, best_partition\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, partition = partition_exhaustive(4, edges)\nprint(cut_value, partition)",0
"def vertex_selection_backtracking(n, edges):\n    def is_valid(selection, node):\n        return all(neighbor not in selection for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, current_set):\n        if node == n:\n            return current_set\n        with_node = backtrack(node + 1, current_set + [node]) if is_valid(current_set, node) else []\n        without_node = backtrack(node + 1, current_set)\n        return max(with_node, without_node, key=len)\n    return backtrack(0, [])\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nselection = vertex_selection_backtracking(4, edges)\nprint(selection)",1
"def nearest_city_route(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = nearest_city_route(cost_matrix)\nprint(cost, route)",2
"def group_backtracking(n, edges):\n    def is_group(nodes):\n        return all((u, v) in edges or (v, u) in edges for u in nodes for v in nodes if u != v)\n    def backtrack(node, current_group):\n        if node == n:\n            return current_group\n        with_node = backtrack(node + 1, current_group + [node]) if is_group(current_group + [node]) else []\n        without_node = backtrack(node + 1, current_group)\n        return max(with_node, without_node, key=len)\n    return backtrack(0, [])\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ngroup = group_backtracking(4, edges)\nprint(group)",3
"def color_assignment_backtracking(n, edges, k):\n    def is_valid_coloring(node, color, colors):\n        return all(colors[neighbor] != color for u, v in edges if u == node for neighbor in [v])\n    def backtrack(node, colors):\n        if node == n:\n            return colors\n        for color in range(k):\n            if is_valid_coloring(node, color, colors):\n                colors[node] = color\n                result = backtrack(node + 1, colors)\n                if result is not None:\n                    return result\n                colors[node] = -1\n        return None\n    return backtrack(0, [-1] * n)\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = color_assignment_backtracking(4, edges, 3)\nprint(colors)",4
"def factorization_recursive(n):\n    def recursive_division(n, divisor=2):\n        if n == 1:\n            return []\n        if n % divisor == 0:\n            return [divisor] + recursive_division(n // divisor, divisor)\n        return recursive_division(n, divisor + 1)\n    return recursive_division(n)\n\n# Input data\nn = 315\nfactors = factorization_recursive(n)\nprint(factors)",5
"def a(n):\n    def b(n, divisor=2):\n        if n == 1:\n            return []\n        if n % divisor == 0:\n            return [divisor] + b(n // divisor, divisor)\n        return b(n, divisor + 1)\n    return b(n)\n\n# Input data\nn = 315\nfactors = a(n)\nprint(factors)",5
"def c(n, edges):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = c(4, edges)\nprint(cut_value, A, B)",0
"def d(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = d(cost_matrix)\nprint(cost, route)",2
"def e(n, edges):\n    selection = set()\n    for node in range(n):\n        if all(neighbor not in selection for u, v in edges if u == node for neighbor in [v]):\n            selection.add(node)\n    return selection\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nselection = e(4, edges)\nprint(selection)",1
"def f(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = f(4, edges, 3)\nprint(colors)",4
"def a(n):\n    def b(n, divisor=2):\n        if n == 1:\n            return []\n        if n % divisor == 0:\n            return [divisor] + b(n // divisor, divisor)\n        return b(n, divisor + 1)\n    return b(n)\n\n# Input data\nn = 315\nfactors = a(n)\nprint(factors)",5
"def f1(n, edges):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = f1(4, edges)\nprint(cut_value, A, B)",0
"def x1(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = x1(cost_matrix)\nprint(cost, route)",2
"def y2(n, edges):\n    selection = set()\n    for node in range(n):\n        if all(neighbor not in selection for u, v in edges if u == node for neighbor in [v]):\n            selection.add(node)\n    return selection\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nselection = y2(4, edges)\nprint(selection)",1
"def z3(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = z3(4, edges, 3)\nprint(colors)",4
"def g3_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 120\nfactors = g3_factorization(n)\nprint(factors)",5
"def factor_skip_even(n):\n    if n % 2 == 0:\n        return 2, n // 2\n    d = 3\n    while d * d <= n:\n        if n % d == 0:\n            return d, n // d\n        d += 2\n    return None\n\nprint(factor_skip_even(27))",5
"def f1(n, edges):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = f1(4, edges)\nprint(cut_value, A, B)",0
"def x1(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = x1(cost_matrix)\nprint(cost, route)",2
"def y2(n, edges):\n    selection = set()\n    for node in range(n):\n        if all(neighbor not in selection for u, v in edges if u == node for neighbor in [v]):\n            selection.add(node)\n    return selection\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nselection = y2(4, edges)\nprint(selection)",1
"def z3(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = z3(4, edges, 3)\nprint(colors)",4
"def g3_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 120\nfactors = g3_factorization(n)\nprint(factors)",5
"def w4(edges, n):\n    best_cut, best_partition = 0, None\n    for mask in range(1 << n):\n        set_A = {i for i in range(n) if mask & (1 << i)}\n        set_B = set(range(n)) - set_A\n        cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B) or (u in set_B and v in set_A))\n        if cut_value > best_cut:\n            best_cut, best_partition = cut_value, (set_A, set_B)\n    return best_cut, best_partition\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nbest_cut, best_partition = w4(edges, 4)\nprint(best_cut, best_partition)",0
"def q5(n, edges):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B) or (u in B and v in A))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = q5(4, edges)\nprint(cut_value, A, B)",0
"def a2(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\ncost, route = a2(cost_matrix)\nprint(cost, route)",2
"def p2(n, edges):\n    group = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in group):\n            group.add(node)\n    return group\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ngroup = p2(4, edges)\nprint(group)",3
"def r4(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncolors = r4(4, edges, 3)\nprint(colors)",4
"def k5_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 72\nfactors = k5_factorization(n)\nprint(factors)",5
"def h7(edges, n):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, set_A, set_B = h7(edges, 4)\nprint(cut_value, set_A, set_B)",0
"def g9(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nindependent_set = g9(4, edges)\nprint(independent_set)",1
"def y8(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 5, 15, 25], [5, 0, 35, 25], [15, 35, 0, 30], [25, 25, 30, 0]]\ncost, route = y8(cost_matrix)\nprint(cost, route)",2
"def v3(n, edges):\n    group = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in group):\n            group.add(node)\n    return group\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ngroup = v3(4, edges)\nprint(group)",3
"def n6_factorization(n):\n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors\n\n# Input data\nn = 144\nfactors = n6_factorization(n)\nprint(factors)",5
"def s3(edges, n):\n    A, B = set(), set()\n    for node in range(n):\n        if sum(1 for u, v in edges if (u == node and v in A)) > sum(1 for u, v in edges if (u == node and v in B)):\n            B.add(node)\n        else:\n            A.add(node)\n    return sum(1 for u, v in edges if (u in A and v in B)), A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncut_value, A, B = s3(edges, 4)\nprint(cut_value, A, B)",0
"def u4_selection(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\nselection = u4_selection(4, edges)\nprint(selection)",1
"def compute_addition(a, b):\n    if b == 0:\n        return a\n    if b > 0:\n        return compute_addition(a + 1, b - 1)\n    return compute_addition(a - 1, b + 1)\n\n# Input data\na, b = -3, 7\nresult = compute_addition(a, b)\nprint(result)",6
"def f_subtract(a, b):\n    return a - b\n\n# Input data\na, b = 10, 7\nresult = f_subtract(a, b)\nprint(result)",8
"def mul_by_splitting(a, b):\n    # simple Karatsuba-style split, but still small integers\n    if a < 10 or b < 10:\n        return a * b\n    a1, a0 = divmod(a, 10)\n    b1, b0 = divmod(b, 10)\n    z2 = a1 * b1\n    z0 = a0 * b0\n    z1 = (a1 + a0) * (b1 + b0) - z2 - z0\n    return z2 * 100 + z1 * 10 + z0\n\nprint(mul_by_splitting(93, 47))",7
"def a(x, y):\n    return x + y\n\n# Input data\nx, y = 15, 27\nresult = a(x, y)\nprint(result)",6
"def b(a, b):\n    return a - b\n\n# Input data\na, b = 12, 5\nresult = b(a, b)\nprint(result)",8
"def mul_accumulate_pairs(pairs):\n    results = []\n    for x, y in pairs:\n        prod = x * y\n        results.append(prod)\n    return results\n\npairs = [(15, 7), (31, 9), (64, 3)]\nprint(mul_accumulate_pairs(pairs))",7
"def g(a, b):\n    return a + b\n\n# Input data\na, b = 8, 2\nresult = g(a, b)\nprint(result)",6
"def h(a, b):\n    return a - b\n\n# Input data\na, b = 20, 10\nresult = h(a, b)\nprint(result)",8
"def i(a, b):\n    return a * b\n\n# Input data\na, b = 7, 8\nresult = i(a, b)\nprint(result)",7
"def x1_add(p, q):\n    return p + q\n\n# Input data\np, q = 33, 22\nresult = x1_add(p, q)\nprint(result)",6
"def sub_with_index(base, offsets):\n    total = base\n    for i, off in enumerate(offsets):\n        if i % 2 == 0:\n            total -= off\n        else:\n            total = total - off\n    return total\n\nprint(sub_with_index(800, [5, 10, 15, 20]))",8
"def z3_mult(a, b):\n    return a * b\n\n# Input data\na, b = 9, 9\nresult = z3_mult(a, b)\nprint(result)",7
"def add(x, y):\n    return x + y\n\n# Input data\nx, y = 19, 21\nresult = add(x, y)\nprint(result)",6
"def subtract(a, b):\n    return a - b\n\n# Input data\na, b = 45, 23\nresult = subtract(a, b)\nprint(result)",8
"def multiply(m, n):\n    return m * n\n\n# Input data\nm, n = 8, 5\nresult = multiply(m, n)\nprint(result)",7
"def g1_add(a, b):\n    return a + b\n\n# Input data\na, b = 100, 200\nresult = g1_add(a, b)\nprint(result)",6
"# Subtraction using a generator expression for multi-operand case\n\ndef sub_gen(a, rest):\n    return a - sum(x for x in rest)\n\nprint(sub_gen(500, [10, 20, 30]))",8
"def j1_multiply(m, n):\n    return m * n\n\n# Input data\nm, n = 11, 6\nresult = j1_multiply(m, n)\nprint(result)",7
"# Simulating hardware carry-lookahead logic (simplified)\n\ndef add_carry_logic(a, b):\n    carry = 0\n    result = 0\n    bit = 0\n    while bit < 16:\n        A = (a >> bit) & 1\n        B = (b >> bit) & 1\n        s = A ^ B ^ carry\n        carry = (A & B) | (A & carry) | (B & carry)\n        result |= (s << bit)\n        bit += 1\n    return result\n\nprint(add_carry_logic(23, 123))",6
"# Bitwise-style subtraction using borrow logic\n\ndef sub_bitwise(a, b):\n    # assumes non-negative integers\n    while b != 0:\n        borrow = (~a) & b\n        a = a ^ b\n        b = borrow << 1\n    return a\n\nprint(sub_bitwise(33, 12))",8
"def m1_multiply(a, b):\n    return a * b\n\n# Input data\na, b = 12, 8\nresult = m1_multiply(a, b)\nprint(result)",7
"def n1_add(a, b):\n    return a + b\n\n# Input data\na, b = 77, 88\nresult = n1_add(a, b)\nprint(result)",6
"def o1_subtract(x, y):\n    return x - y\n\n# Input data\nx, y = 90, 45\nresult = o1_subtract(x, y)\nprint(result)",8
"def p1_multiply(x, y):\n    return x * y\n\n# Input data\nx, y = 13, 7\nresult = p1_multiply(x, y)\nprint(result)",7
"# Using tuple unpacking and comprehension\n\ndef add_unpack(a, b):\n    return sum([x for x in (a, b)])\n\nprint(add_unpack(400, 500))",6
"def s1_subtract(a, b):\n    return a - b\n\n# Input data\na, b = 87, 50\nresult = s1_subtract(a, b)\nprint(result)",8
"def t1_multiply(m, n):\n    return m * n\n\n# Input data\nm, n = 25, 5\nresult = t1_multiply(m, n)\nprint(result)",7
"def u1_add(a, b):\n    return a + b\n\n# Input data\na, b = 300, 150\nresult = u1_add(a, b)\nprint(result)",6
"# Recursive subtraction using decrement on b\n\ndef sub_recursive(a, b):\n    if b == 0:\n        return a\n    return sub_recursive(a - 1, b - 1)\n\nprint(sub_recursive(300, 45))",8
"def w1_multiply(a, b):\n    return a * b\n\n# Input data\na, b = 15, 9\nresult = w1_multiply(a, b)\nprint(result)",7
"def x1_add(p, q):\n    return p + q\n\n# Input data\np, q = 125, 375\nresult = x1_add(p, q)\nprint(result)",6
"def f_sub_simple(a, b):\n    return a - b\n\nx, y = 512, 123\nresult = f_sub_simple(x, y)\nprint(result)",8
"def z1_multiply(a, b):\n    return a * b\n\n# Input data\na, b = 45, 23\nresult = z1_multiply(a, b)\nprint(result)",7
"def a2_add(a, b):\n    return a + b\n\n# Input data\na, b = 78, 92\nresult = a2_add(a, b)\nprint(result)",6
"def b2_subtract(x, y):\n    return x - y\n\n# Input data\nx, y = 300, 120\nresult = b2_subtract(x, y)\nprint(result)",8
"def f_add(a, b):\n    return a + b\n\n# Input data\na, b = 10, 20\nresult = f_add(a, b)\nprint(result)",6
"from functools import reduce\n\ndef f_add(a, b):\n    return reduce(lambda acc, x: acc + x, [a, b])\n\na, b = 9, 14\nresult = f_add(a, b)\nprint(result),6
",6
"def sum_two(p, q):\n    return p + q\n\np, q = 45, 55\nresult = sum_two(p, q)\nprint(result)",6
"def add_simple(x, y):\n    return x + y\n\nx, y = 3, 4\nresult = add_simple(x, y)\nprint(result)",6
"def simple_sub(a, b):\n    return a - b\n\n# Input data\na, b = 15, 5\nresult = simple_sub(a, b)\nprint(result)",8
"def sub_two(x, y):\n    return x - y\n\n# Input data\nx, y = 100, 50\nresult = sub_two(x, y)\nprint(result)",8
"def diff_calc(a, b):\n    return a - b\n\n# Input data\na, b = 42, 18\nresult = diff_calc(a, b)\nprint(result)",8
"def subtract_vals(x, y):\n    return x - y\n\n# Input data\nx, y = 33, 11\nresult = subtract_vals(x, y)\nprint(result)",8
"def multiply_vals(x, y):\n    return x * y\n\n# Input data\nx, y = 9, 8\nresult = multiply_vals(x, y)\nprint(result)",7
"def f_multiply(a, b):\n    return a * b\n\n# Input data\na, b = 6, 7\nresult = f_multiply(a, b)\nprint(result)",7
"def g_multiply(p, q):\n    return p * q\n\n# Input data\np, q = 4, 12\nresult = g_multiply(p, q)\nprint(result)",7
"def simple_mult(a, b):\n    return a * b\n\n# Input data\na, b = 14, 6\nresult = simple_mult(a, b)\nprint(result)",7
"def max_partition(edges, n):\n    A, B = set(), set()\n    for node in range(n):\n        if len(A) < len(B):\n            A.add(node)\n        else:\n            B.add(node)\n    return sum(1 for u, v in edges if (u in A and v in B)), A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncut_value, A, B = max_partition(edges, 4)\nprint(cut_value, A, B)",0
"def min_cut_strategy(edges, n):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncut_value, set_A, set_B = min_cut_strategy(edges, 4)\nprint(cut_value, set_A, set_B)",0
"def independent_nodes(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nindependent_set = independent_nodes(4, edges)\nprint(independent_set)",1
"def max_independent(n, edges):\n    group = set()\n    for node in range(n):\n        if all(neighbor not in group for u, v in edges if u == node for neighbor in [v]):\n            group.add(node)\n    return group\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = max_independent(4, edges)\nprint(result)",1
"def tsp_greedy(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 15], [10, 0, 35], [15, 35, 0]]\ncost, route = tsp_greedy(cost_matrix)\nprint(cost, route)",2
"def nearest_neighbor(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 8, 20], [8, 0, 30], [20, 30, 0]]\ncost, route = nearest_neighbor(cost_matrix)\nprint(cost, route)",2
"def clique_search(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = clique_search(4, edges)\nprint(result)",3
"def find_clique(n, edges):\n    max_clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in max_clique):\n            max_clique.add(node)\n    return max_clique\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = find_clique(4, edges)\nprint(result)",3
"def coloring_greedy(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = coloring_greedy(4, edges, 3)\nprint(colors)",4
"def kcolor_assignment(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = kcolor_assignment(4, edges, 3)\nprint(colors)",4
"def helper(values):\n    s = 0\n    for v in values:\n        s += v\n    return s\n\ndef compute_addition(a, b):\n    if a == b:\n        return a + b\n    return helper([a, b])\n\n# Input data\na, b = 9, 4\nresult = compute_addition(a, b)\nprint(result)",6
"def compute_addition(a, b):\n    return a + b\n\n# Input data\na, b = 31, 19\nresult = compute_addition(a, b)\nprint(result)",6
"def add_two_values(p, q):\n    return p + q\n\n# Input data\np, q = 58, 42\nresult = add_two_values(p, q)\nprint(result)",6
"class AddOp:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n    def compute_addition(self):\n        return self.x + self.y\n\n# Input data\nop = AddOp(12, -5)\nresult = op.compute_addition()\nprint(result)",6
"def subtract_simple(a, b):\n    return a - b\n\n# Input data\na, b = 88, 20\nresult = subtract_simple(a, b)\nprint(result)",8
"def compute_difference(x, y):\n    return x - y\n\n# Input data\nx, y = 50, 25\nresult = compute_difference(x, y)\nprint(result)",8
"def subtract_two_values(a, b):\n    return a - b\n\n# Input data\na, b = 91, 33\nresult = subtract_two_values(a, b)\nprint(result)",8
"def find_difference(x, y):\n    return x - y\n\n# Input data\nx, y = 62, 21\nresult = find_difference(x, y)\nprint(result)",8
"def calc_multiplication(x, y):\n    return x * y\n\n# Input data\nx, y = 7, 8\nresult = calc_multiplication(x, y)\nprint(result)",7
"def basic_mult(a, b):\n    return a * b\n\n# Input data\na, b = 13, 14\nresult = basic_mult(a, b)\nprint(result)",7
"def compute_product(p, q):\n    return p * q\n\n# Input data\np, q = 9, 9\nresult = compute_product(p, q)\nprint(result)",7
"def multiply_simple(a, b):\n    return a * b\n\n# Input data\na, b = 19, 3\nresult = multiply_simple(a, b)\nprint(result)",7
"def cut_partition(edges, n):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return sum(1 for u, v in edges if (u in set_A and v in set_B)), set_A, set_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncut_value, set_A, set_B = cut_partition(edges, 4)\nprint(cut_value, set_A, set_B)",0
"def simple_cut_strategy(edges, n):\n    A, B = set(), set()\n    for node in range(n):\n        if len(A) < len(B):\n            A.add(node)\n        else:\n            B.add(node)\n    return sum(1 for u, v in edges if (u in A and v in B)), A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncut_value, A, B = simple_cut_strategy(edges, 4)\nprint(cut_value, A, B)",0
"def compute_independent(n, edges):\n    selection = set()\n    for node in range(n):\n        if all(neighbor not in selection for u, v in edges if u == node for neighbor in [v]):\n            selection.add(node)\n    return selection\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nselection = compute_independent(4, edges)\nprint(selection)",1
"def independent_calc(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = independent_calc(4, edges)\nprint(result)",1
"def tsp_heuristic(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 5, 20], [5, 0, 30], [20, 30, 0]]\ncost, route = tsp_heuristic(cost_matrix)\nprint(cost, route)",2
"def greedy_tsp(cost_matrix):\n    n = len(cost_matrix)\n    unvisited = set(range(1, n))\n    route, total_cost = [0], 0\n    current = 0\n    while unvisited:\n        next_city = min(unvisited, key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        route.append(next_city)\n        unvisited.remove(next_city)\n        current = next_city\n    total_cost += cost_matrix[route[-1]][0]\n    return total_cost, route\n\n# Input data\ncost_matrix = [[0, 10, 25], [10, 0, 35], [25, 35, 0]]\ncost, route = greedy_tsp(cost_matrix)\nprint(cost, route)",2
"def clique_max_search(n, edges):\n    clique = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = clique_max_search(4, edges)\nprint(result)",3
"def max_clique_calc(n, edges):\n    group = set()\n    for node in range(n):\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in group):\n            group.add(node)\n    return group\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = max_clique_calc(4, edges)\nprint(result)",3
"def greedy_kcoloring(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = greedy_kcoloring(4, edges, 3)\nprint(colors)",4
"def kcolor_strategy(n, edges, k):\n    colors = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = kcolor_strategy(4, edges, 3)\nprint(colors)",4
"def sum_func(x1, x2):\n    return x1 + x2\n\n# Input data\nx1, x2 = 10, 15\nresult = sum_func(x1, x2)\nprint(result)",6
"def plus_op(a, b):\n    return a + b\n\n# Input data\na, b = 23, 32\nresult = plus_op(a, b)\nprint(result)",6
"def total(x, y):\n    return x + y\n\n# Input data\nx, y = 45, 5\nresult = total(x, y)\nprint(result)",6
"def simple_plus(v1, v2):\n    return v1 + v2\n\n# Input data\nv1, v2 = 100, 1\nresult = simple_plus(v1, v2)\nprint(result)",6
"def diff_func(p, q):\n    return p - q\n\n# Input data\np, q = 70, 50\nresult = diff_func(p, q)\nprint(result)",8
"def minus_op(n1, n2):\n    return n1 - n2\n\n# Input data\nn1, n2 = 99, 12\nresult = minus_op(n1, n2)\nprint(result)",8
"def subtract_it(val1, val2):\n    return val1 - val2\n\n# Input data\nval1, val2 = 300, 100\nresult = subtract_it(val1, val2)\nprint(result)",8
"def take_away(x, y):\n    return x - y\n\n# Input data\nx, y = 20, 5\nresult = take_away(x, y)\nprint(result)",8
"def multiply_func(i, j):\n    return i * j\n\n# Input data\ni, j = 6, 12\nresult = multiply_func(i, j)\nprint(result)",7
"def mult_two_numbers(val1, val2):\n    return val1 * val2\n\n# Input data\nval1, val2 = 13, 4\nresult = mult_two_numbers(val1, val2)\nprint(result)",7
"def calc_product(n1, n2):\n    return n1 * n2\n\n# Input data\nn1, n2 = 10, 9\nresult = calc_product(n1, n2)\nprint(result)",7
"def product_of(x, y):\n    return x * y\n\n# Input data\nx, y = 100, 2\nresult = product_of(x, y)\nprint(result)",7
"def max_cut_solution(edges, num_nodes):\n    A, B = set(), set()\n    for node in range(num_nodes):\n        if len(A) < len(B):\n            A.add(node)\n        else:\n            B.add(node)\n    cut_value = sum(1 for u, v in edges if (u in A and v in B))\n    return cut_value, A, B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncut_value, A, B = max_cut_solution(edges, 4)\nprint(cut_value, A, B)",0
"def independent_set_finder(nodes, edges):\n    iset = set()\n    for node in nodes:\n        if all(neighbor not in iset for u, v in edges if u == node for neighbor in [v]):\n            iset.add(node)\n    return iset\n\n# Input data\nnodes = [0, 1, 2, 3]\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = independent_set_finder(nodes, edges)\nprint(result)",1
"def compute_clique(nodes, edges):\n    clique = set()\n    for node in nodes:\n        if all((node, neighbor) in edges or (neighbor, node) in edges for neighbor in clique):\n            clique.add(node)\n    return clique\n\n# Input data\nnodes = [0, 1, 2, 3]\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = compute_clique(nodes, edges)\nprint(result)",3
"def tsp_solver(dist_matrix):\n    n = len(dist_matrix)\n    visited = [0]\n    total_cost = 0\n    current = 0\n    while len(visited) < n:\n        next_city = min([city for city in range(n) if city not in visited], key=lambda city: dist_matrix[current][city])\n        total_cost += dist_matrix[current][next_city]\n        visited.append(next_city)\n        current = next_city\n    total_cost += dist_matrix[visited[-1]][0]\n    return total_cost, visited\n\n# Input data\ndist_matrix = [[0, 15, 20], [15, 0, 35], [20, 35, 0]]\ncost, route = tsp_solver(dist_matrix)\nprint(cost, route)",2
"def greedy_coloring(nodes, edges, k):\n    color_map = [-1] * len(nodes)\n    for node in nodes:\n        neighbor_colors = {color_map[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        available_colors = set(range(k)) - neighbor_colors\n        color_map[node] = min(available_colors) if available_colors else -1\n    return color_map\n\n# Input data\nnodes = [0, 1, 2, 3]\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = greedy_coloring(nodes, edges, 3)\nprint(colors)",4
"def compute_coloring(n, edges, k):\n    color_assignment = [-1] * n\n    for node in range(n):\n        available_colors = set(range(k)) - {color_assignment[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        if available_colors:\n            color_assignment[node] = min(available_colors)\n    return color_assignment\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = compute_coloring(4, edges, 3)\nprint(colors)",4
"def independent_set_finder_v2(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nselection = independent_set_finder_v2(4, edges)\nprint(selection)",1
"def partition_strategy(edges, nodes):\n    group_A, group_B = set(), set()\n    for node in nodes:\n        if len(group_A) < len(group_B):\n            group_A.add(node)\n        else:\n            group_B.add(node)\n    return group_A, group_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ngroup_A, group_B = partition_strategy(edges, [0, 1, 2, 3])\nprint(group_A, group_B)",0
"def color_assignment_solver(n, edges, colors_available):\n    colors = [-1] * n\n    for node in range(n):\n        used_colors = {colors[neighbor] for u, v in edges if u == node for neighbor in [v]}\n        available_colors = set(colors_available) - used_colors\n        if available_colors:\n            colors[node] = min(available_colors)\n    return colors\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncolors = color_assignment_solver(4, edges, [0, 1, 2])\nprint(colors)",4
"def f(a, b):\n    return a + b\n\n# Input data\na, b = 25, 17\nresult = f(a, b)\nprint(result)",6
"def f_add_bitwise(a, b):\n    # Bitwise addition using XOR and carry\n    while b != 0:\n        carry = a & b\n        a = a ^ b\n        b = carry << 1\n    return a\n\nx, y = 300, 700\nprint(f_add_bitwise(x, y))",6
"def do_something(a, b):\n    return a + b\n\n# Input data\na, b = 12, 7\nresult = do_something(a, b)\nprint(result)",6
"# Recursive addition using decrement\n\ndef add_recursive(a, b):\n    if b == 0:\n        return a\n    return add_recursive(a + 1, b - 1)\n\nprint(add_recursive(50, 20))",6
"def f(a, b):\n    return a - b\n\n# Input data\na, b = 10, 4\nresult = f(a, b)\nprint(result)",8
"def a(x, y):\n    return x - y\n\n# Input data\nx, y = 25, 10\nresult = a(x, y)\nprint(result)",8
"def do_something(a, b):\n    return a - b\n\n# Input data\na, b = 100, 50\nresult = do_something(a, b)\nprint(result)",8
"def subtract_vals(x, y):\n    return x - y\n\n# Input data\nx, y = 17, 5\nresult = subtract_vals(x, y)\nprint(result)",8
"def f(a, b):\n    return a * b\n\n# Input data\na, b = 6, 7\nresult = f(a, b)\nprint(result)",7
"def a(x, y):\n    return x * y\n\n# Input data\nx, y = 9, 9\nresult = a(x, y)\nprint(result)",7
"def do_something(p, q):\n    return p * q\n\n# Input data\np, q = 8, 4\nresult = do_something(p, q)\nprint(result)",7
"def multiply_values(a, b):\n    return a * b\n\n# Input data\na, b = 10, 11\nresult = multiply_values(a, b)\nprint(result)",7
"def f(edges, n):\n    set_A, set_B = set(), set()\n    for node in range(n):\n        if len(set_A) < len(set_B):\n            set_A.add(node)\n        else:\n            set_B.add(node)\n    cut_value = sum(1 for u, v in edges if (u in set_A and v in set_B))\n    return cut_value, set_A, set_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncut_value, set_A, set_B = f(edges, 4)\nprint(cut_value, set_A, set_B)",0
"def a(nodes, edges):\n    independent_set = set()\n    for node in nodes:\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nnodes = [0, 1, 2, 3]\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = a(nodes, edges)\nprint(result)",1
"def do_something(n, edges):\n    independent_set = set()\n    for node in range(n):\n        if all(neighbor not in independent_set for u, v in edges if u == node for neighbor in [v]):\n            independent_set.add(node)\n    return independent_set\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = do_something(4, edges)\nprint(result)",1
"def f(dist_matrix):\n    n = len(dist_matrix)\n    visited = [0]\n    total_cost = 0\n    current = 0\n    while len(visited) < n:\n        next_city = min([city for city in range(n) if city not in visited], key=lambda city: dist_matrix[current][city])\n        total_cost += dist_matrix[current][next_city]\n        visited.append(next_city)\n        current = next_city\n    total_cost += dist_matrix[visited[-1]][0]\n    return total_cost, visited\n\n# Input data\ndist_matrix = [[0, 12, 24], [12, 0, 36], [24, 36, 0]]\ncost, route = f(dist_matrix)\nprint(cost, route)",2
"def a(cost_matrix):\n    n = len(cost_matrix)\n    visited = [0]\n    total_cost = 0\n    current = 0\n    while len(visited) < n:\n        next_city = min([city for city in range(n) if city not in visited], key=lambda city: cost_matrix[current][city])\n        total_cost += cost_matrix[current][next_city]\n        visited.append(next_city)\n        current = next_city\n    total_cost += cost_matrix[visited[-1]][0]\n    return total_cost, visited\n\n# Input data\ncost_matrix = [[0, 11, 30], [11, 0, 35], [30, 35, 0]]\ncost, route = a(cost_matrix)\nprint(cost, route)",2
"def do_something(dist_matrix):\n    n = len(dist_matrix)\n    visited = [0]\n    total_cost = 0\n    current = 0\n    while len(visited) < n:\n        next_city = min([city for city in range(n) if city not in visited], key=lambda city: dist_matrix[current][city])\n        total_cost += dist_matrix[current][next_city]\n        visited.append(next_city)\n        current = next_city\n    total_cost += dist_matrix[visited[-1]][0]\n    return total_cost, visited\n\n# Input data\ndist_matrix = [[0, 18, 22], [18, 0, 27], [22, 27, 0]]\ncost, route = do_something(dist_matrix)\nprint(cost, route)",2
"def f(n, edges):\n    group_A, group_B = set(), set()\n    for node in range(n):\n        if len(group_A) < len(group_B):\n            group_A.add(node)\n        else:\n            group_B.add(node)\n    return group_A, group_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ngroup_A, group_B = f(4, edges)\nprint(group_A, group_B)",0
"def a(n, edges):\n    set_A, set_B = set(), set(range(n))\n    for u, v in edges:\n        if len(set_A) < len(set_B):\n            set_A.add(u)\n        else:\n            set_B.add(v)\n    return set_A, set_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nset_A, set_B = a(4, edges)\nprint(set_A, set_B)",0
"def do_something(n, edges):\n    group_A, group_B = set(), set()\n    for node in range(n):\n        if len(group_A) < len(group_B):\n            group_A.add(node)\n        else:\n            group_B.add(node)\n    return group_A, group_B\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ngroup_A, group_B = do_something(4, edges)\nprint(group_A, group_B)",0
"def min_vertex_cover_bruteforce(n, edges):\n    min_cover = set()\n    for i in range(1 << n):\n        cover = {j for j in range(n) if i & (1 << j)}\n        if all(u in cover or v in cover for u, v in edges):\n            if not min_cover or len(cover) < len(min_cover):\n                min_cover = cover\n    return min_cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\nmin_cover = min_vertex_cover_bruteforce(4, edges)\nprint(min_cover)",9
"def vertex_cover_greedy(n, edges):\n    cover = set()\n    remaining_edges = set(edges)\n    while remaining_edges:\n        u, v = remaining_edges.pop()\n        cover.add(u)\n        cover.add(v)\n        remaining_edges = {e for e in remaining_edges if u not in e and v not in e}\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 4)]\ncover = vertex_cover_greedy(5, edges)\nprint(cover)",9
"def greedy_min_vertex_cover(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncover = greedy_min_vertex_cover(4, edges)\nprint(cover)",9
"def approx_vertex_cover(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 4)]\ncover = approx_vertex_cover(5, edges)\nprint(cover)",9
"def min_cover_fast(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 3), (3, 4), (0, 2)]\ncover = min_cover_fast(5, edges)\nprint(cover)",9
"def find_vertex_cover(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncover = find_vertex_cover(4, edges)\nprint(cover)",9
"def vertex_cover(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 4)]\ncover = vertex_cover(5, edges)\nprint(cover)",9
"def simple_min_vertex_cover(edges, n):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncover = simple_min_vertex_cover(edges, 4)\nprint(cover)",9
"def min_vertex_cover(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 4)]\ncover = min_vertex_cover(5, edges)\nprint(cover)",9
"def vertex_cover_algorithm(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncover = vertex_cover_algorithm(4, edges)\nprint(cover)",9
"def approximate_vertex_cover(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 4)]\ncover = approximate_vertex_cover(5, edges)\nprint(cover)",9
"def quick_vertex_cover(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncover = quick_vertex_cover(4, edges)\nprint(cover)",9
"def fast_min_vertex_cover(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 4)]\ncover = fast_min_vertex_cover(5, edges)\nprint(cover)",9
"def vertex_cover_min(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncover = vertex_cover_min(4, edges)\nprint(cover)",9
"def cover_vertices(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncover = cover_vertices(4, edges)\nprint(cover)",9
"def vertex_cover_approximation(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3), (3, 4)]\ncover = vertex_cover_approximation(5, edges)\nprint(cover)",9
"def find_min_vertex_cover(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nedges = [(0, 1), (1, 2), (2, 3)]\ncover = find_min_vertex_cover(4, edges)\nprint(cover)",9
"def f_cover(vertices, edges):\n    cover_set = set()\n    for u, v in edges:\n        if u not in cover_set and v not in cover_set:\n            cover_set.add(u)\n            cover_set.add(v)\n    return cover_set\n\n# Input data\nvertices = 4\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = f_cover(vertices, edges)\nprint(result)",9
"def a_cover(n, e):\n    c_set = set()\n    for u, v in e:\n        if u not in c_set and v not in c_set:\n            c_set.add(u)\n            c_set.add(v)\n    return c_set\n\n# Input data\nn = 4\ne = [(0, 1), (1, 2), (2, 3)]\nresult = a_cover(n, e)\nprint(result)",9
"def find_cover(n, edge_list):\n    vertex_cover = set()\n    for u, v in edge_list:\n        if u not in vertex_cover and v not in vertex_cover:\n            vertex_cover.add(u)\n            vertex_cover.add(v)\n    return vertex_cover\n\n# Input data\nedge_list = [(0, 1), (1, 2), (2, 3)]\nresult = find_cover(4, edge_list)\nprint(result)",9
"def cover_set(V, E):\n    C = set()\n    for u, v in E:\n        if u not in C and v not in C:\n            C.add(u)\n            C.add(v)\n    return C\n\n# Input data\nV = 5\nE = [(0, 1), (1, 2), (3, 4)]\nresult = cover_set(V, E)\nprint(result)",9
"def vertex_min_cover(vertices, edges):\n    C = set()\n    for u, v in edges:\n        if u not in C and v not in C:\n            C.add(u)\n            C.add(v)\n    return C\n\n# Input data\nvertices = 4\nedges = [(0, 1), (1, 2), (2, 3)]\nmin_cover = vertex_min_cover(vertices, edges)\nprint(min_cover)",9
"def greedy_cover(vertex_count, edge_list):\n    cover_set = set()\n    for u, v in edge_list:\n        if u not in cover_set and v not in cover_set:\n            cover_set.add(u)\n            cover_set.add(v)\n    return cover_set\n\n# Input data\nvertex_count = 6\nedge_list = [(0, 1), (1, 3), (3, 5)]\nmin_cover = greedy_cover(vertex_count, edge_list)\nprint(min_cover)",9
"def get_vertex_cover(V, E):\n    C = set()\n    for u, v in E:\n        if u not in C and v not in C:\n            C.add(u)\n            C.add(v)\n    return C\n\n# Input data\nV = 4\nE = [(0, 1), (1, 2), (2, 3)]\ncover = get_vertex_cover(V, E)\nprint(cover)",9
"def cover_algo(v_count, e_list):\n    C = set()\n    for u, v in e_list:\n        if u not in C and v not in C:\n            C.add(u)\n            C.add(v)\n    return C\n\n# Input data\nv_count = 5\ne_list = [(0, 1), (1, 3), (2, 4)]\ncover = cover_algo(v_count, e_list)\nprint(cover)",9
"def solve_vertex_cover(V, E):\n    cover = set()\n    for u, v in E:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nV = 4\nE = [(0, 1), (1, 2), (2, 3)]\nresult = solve_vertex_cover(V, E)\nprint(result)",9
"def calc_vertex_cover(v, e):\n    cover = set()\n    for u, v in e:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nv = 5\ne = [(0, 1), (2, 3), (3, 4)]\nresult = calc_vertex_cover(v, e)\nprint(result)",9
"def find_vc(V, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nV = 4\nedges = [(0, 1), (1, 2), (2, 3)]\nresult = find_vc(V, edges)\nprint(result)",9
"def get_cover(v_count, e):\n    C = set()\n    for u, v in e:\n        if u not in C and v not in C:\n            C.add(u)\n            C.add(v)\n    return C\n\n# Input data\nv_count = 5\ne = [(0, 1), (1, 2), (2, 3), (3, 4)]\ncover = get_cover(v_count, e)\nprint(cover)",9
"def simple_vc(vertices, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nvertices = 6\nedges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]\nvc = simple_vc(vertices, edges)\nprint(vc)",9
"def vc_solution(n, edge_list):\n    C = set()\n    for u, v in edge_list:\n        if u not in C and v not in C:\n            C.add(u)\n            C.add(v)\n    return C\n\n# Input data\nn = 4\nedge_list = [(0, 1), (1, 2), (2, 3)]\nvc = vc_solution(n, edge_list)\nprint(vc)",9
"def find_min_cover(v, e):\n    cover = set()\n    for u, v in e:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nv = 6\ne = [(0, 1), (1, 2), (3, 4)]\ncover = find_min_cover(v, e)\nprint(cover)",9
"def greedy_vc(V, E):\n    C = set()\n    for u, v in E:\n        if u not in C and v not in C:\n            C.add(u)\n            C.add(v)\n    return C\n\n# Input data\nV = 5\nE = [(0, 1), (1, 2), (2, 3), (3, 4)]\nvc = greedy_vc(V, E)\nprint(vc)",9
"def fast_vertex_cover(n, e):\n    cover = set()\n    for u, v in e:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nn = 6\ne = [(0, 1), (2, 3), (4, 5)]\nvc = fast_vertex_cover(n, e)\nprint(vc)",9
"def calculate_cover(V, E):\n    cover_set = set()\n    for u, v in E:\n        if u not in cover_set and v not in cover_set:\n            cover_set.add(u)\n            cover_set.add(v)\n    return cover_set\n\n# Input data\nV = 5\nE = [(0, 1), (1, 3), (2, 4)]\nvc = calculate_cover(V, E)\nprint(vc)",9
"def find_vertex_cover(n, e):\n    cover = set()\n    for u, v in e:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nn = 6\ne = [(0, 1), (1, 2), (2, 3)]\nvc = find_vertex_cover(n, e)\nprint(vc)",9
"def calc_vc(v, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nv = 4\nedges = [(0, 1), (1, 2), (2, 3)]\nvc = calc_vc(v, edges)\nprint(vc)",9
"def compute_vertex_cover(n, edges):\n    cover = set()\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nn = 6\nedges = [(0, 1), (1, 2), (2, 3)]\nvc = compute_vertex_cover(n, edges)\nprint(vc)",9
"def fast_vc(n, e):\n    cover = set()\n    for u, v in e:\n        if u not in cover and v not in cover:\n            cover.add(u)\n            cover.add(v)\n    return cover\n\n# Input data\nn = 5\ne = [(0, 1), (1, 2), (2, 3), (3, 4)]\nvc = fast_vc(n, e)\nprint(vc)",9
"import itertools\n\n# Brute-force minimum vertex cover for a small graph\n\ndef min_vertex_cover_bruteforce(edges, n):\n    nodes = list(range(n))\n    best_cover = None\n    for r in range(n + 1):\n        for subset in itertools.combinations(nodes, r):\n            cover = set(subset)\n            ok = True\n            for u, v in edges:\n                if u not in cover and v not in cover:\n                    ok = False\n                    break\n            if ok:\n                best_cover = cover\n                return best_cover\n    return best_cover\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ncover = min_vertex_cover_bruteforce(edges, 4)\nprint(sorted(cover))",9
"import networkx as nx\n\n# 2-approximation using a maximal matching\n\ndef approx_vertex_cover_matching(G):\n    cover = set()\n    matching = set()\n    for u, v in G.edges():\n        if u not in cover and v not in cover:\n            matching.add((u, v))\n            cover.add(u)\n            cover.add(v)\n    return cover\n\nG = nx.Graph()\nG.add_edges_from([(0, 1), (1, 3), (3, 4), (2, 4), (2, 5)])\nvc = approx_vertex_cover_matching(G)\nprint(sorted(vc))",9
"# Greedy heuristic: always pick the node with highest degree\n\ndef greedy_vertex_cover(edges, n):\n    adj = {i: set() for i in range(n)}\n    for u, v in edges:\n        adj[u].add(v)\n        adj[v].add(u)\n    uncovered = set(edges)\n    cover = set()\n    while uncovered:\n        # compute current degrees on uncovered edges\n        degree = {i: 0 for i in range(n)}\n        for u, v in uncovered:\n            degree[u] += 1\n            degree[v] += 1\n        # select node with maximum uncovered degree\n        best = max(degree, key=degree.get)\n        cover.add(best)\n        # remove all edges incident to best\n        uncovered = {(u, v) for (u, v) in uncovered if best not in (u, v)}\n    return cover\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 4), (2, 4)]\nprint(sorted(greedy_vertex_cover(edges, 5)))",9
"# While-loop style with explicit edge list updates\n\ndef min_vertex_cover_simple(edges, n):\n    edges = list(edges)\n    cover = set()\n    while edges:\n        u, v = edges[0]\n        # add both endpoints to cover (simple 2-approx scheme)\n        cover.add(u)\n        cover.add(v)\n        new_edges = []\n        for x, y in edges:\n            if x not in cover and y not in cover:\n                new_edges.append((x, y))\n        edges = new_edges\n    return cover\n\nedges = [(0, 1), (0, 2), (1, 3), (2, 4), (4, 6)]\nprint(sorted(min_vertex_cover_simple(edges, 7)))",9
"import itertools\n\n# Branch-and-bound style search for minimum vertex cover\n\ndef is_cover(cover, edges):\n    for u, v in edges:\n        if u not in cover and v not in cover:\n            return False\n    return True\n\ndef min_vertex_cover_bnb(edges, n):\n    best = None\n    nodes = list(range(n))\n    for r in range(1, n + 1):\n        for subset in itertools.combinations(nodes, r):\n            cover = set(subset)\n            if is_cover(cover, edges):\n                best = cover\n                return best\n    return best\n\nedges = [(0, 1), (1, 2), (2, 5), (3, 5), (4, 6)]\ncover = min_vertex_cover_bnb(edges, 7)\nprint(sorted(cover))",9
"# Minimum vertex cover using pure while-loops\n\ndef vertex_cover_while(edges, n):\n    cover = set()\n    remaining = list(edges)\n    idx = 0\n    while idx < len(remaining):\n        u, v = remaining[idx]\n        cover.add(u)\n        cover.add(v)\n        # filter uncovered edges\n        new_edges = []\n        j = 0\n        while j < len(remaining):\n            x, y = remaining[j]\n            if x not in cover and y not in cover:\n                new_edges.append((x, y))\n            j += 1\n        remaining = new_edges\n        idx = 0\n    return cover\n\nedges = [(0,1),(1,3),(2,3),(3,5)]\nprint(sorted(vertex_cover_while(edges, 6)))",9
"def vc_while_degree_based(edges, n):\n    # adjacency list\n    adj = {i: set() for i in range(n)}\n    k = 0\n    while k < len(edges):\n        u, v = edges[k]\n        adj[u].add(v)\n        adj[v].add(u)\n        k += 1\n\n    cover = set()\n    uncovered = list(edges)\n\n    while len(uncovered) > 0:\n        # compute degrees using while only\n        deg = {i: 0 for i in range(n)}\n        idx = 0\n        while idx < len(uncovered):\n            u, v = uncovered[idx]\n            deg[u] += 1\n            deg[v] += 1\n            idx += 1\n\n        # choose highest-degree node\n        best = max(deg, key=deg.get)\n        cover.add(best)\n\n        # remove edges covered by 'best'\n        new_uncovered = []\n        j = 0\n        while j < len(uncovered):\n            u, v = uncovered[j]\n            if best not in (u, v):\n                new_uncovered.append((u, v))\n            j += 1\n        uncovered = new_uncovered\n\n    return cover\n\nedges = [(0,2),(2,3),(3,4),(1,4),(4,6)]\nprint(sorted(vc_while_degree_based(edges, 7)))",9
"# Pure while-loop greedy cover: always pick first edge\n\ndef vc_while_simple(edges):\n    edges = list(edges)\n    cover = set()\n    i = 0\n    while len(edges) > 0:\n        u, v = edges[0]\n        cover.add(u)\n        cover.add(v)\n        new_edges = []\n\n        j = 0\n        while j < len(edges):\n            x, y = edges[j]\n            if x not in cover and y not in cover:\n                new_edges.append((x, y))\n            j += 1\n\n        edges = new_edges\n        i = 0\n    return cover\n\nedges = [(0,1),(1,2),(2,3),(3,5),(4,6)]\nprint(sorted(vc_while_simple(edges)))",9
